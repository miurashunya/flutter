// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'single_class_constructor.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Dynamic {
  dynamic get foo => throw _privateConstructorUsedError;
  dynamic? get bar => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DynamicCopyWith<Dynamic> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DynamicCopyWith<$Res> {
  factory $DynamicCopyWith(Dynamic value, $Res Function(Dynamic) then) =
      _$DynamicCopyWithImpl<$Res, Dynamic>;
  @useResult
  $Res call({dynamic foo, dynamic? bar});
}

/// @nodoc
class _$DynamicCopyWithImpl<$Res, $Val extends Dynamic>
    implements $DynamicCopyWith<$Res> {
  _$DynamicCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? foo = freezed,
    Object? bar = freezed,
  }) {
    return _then(_value.copyWith(
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as dynamic,
      bar: freezed == bar
          ? _value.bar
          : bar // ignore: cast_nullable_to_non_nullable
              as dynamic?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DynamicFirstCopyWith<$Res> implements $DynamicCopyWith<$Res> {
  factory _$$DynamicFirstCopyWith(
          _$DynamicFirst value, $Res Function(_$DynamicFirst) then) =
      __$$DynamicFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({dynamic foo, dynamic? bar});
}

/// @nodoc
class __$$DynamicFirstCopyWithImpl<$Res>
    extends _$DynamicCopyWithImpl<$Res, _$DynamicFirst>
    implements _$$DynamicFirstCopyWith<$Res> {
  __$$DynamicFirstCopyWithImpl(
      _$DynamicFirst _value, $Res Function(_$DynamicFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? foo = freezed,
    Object? bar = freezed,
  }) {
    return _then(_$DynamicFirst(
      foo: freezed == foo
          ? _value.foo
          : foo // ignore: cast_nullable_to_non_nullable
              as dynamic,
      bar: freezed == bar
          ? _value.bar
          : bar // ignore: cast_nullable_to_non_nullable
              as dynamic?,
    ));
  }
}

/// @nodoc

class _$DynamicFirst implements DynamicFirst {
  _$DynamicFirst({this.foo, this.bar});

  @override
  final dynamic foo;
  @override
  final dynamic? bar;

  @override
  String toString() {
    return 'Dynamic(foo: $foo, bar: $bar)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DynamicFirst &&
            const DeepCollectionEquality().equals(other.foo, foo) &&
            const DeepCollectionEquality().equals(other.bar, bar));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(foo),
      const DeepCollectionEquality().hash(bar));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$DynamicFirstCopyWith<_$DynamicFirst> get copyWith =>
      __$$DynamicFirstCopyWithImpl<_$DynamicFirst>(this, _$identity);
}

abstract class DynamicFirst implements Dynamic {
  factory DynamicFirst({final dynamic foo, final dynamic? bar}) =
      _$DynamicFirst;

  @override
  dynamic get foo;
  @override
  dynamic? get bar;
  @override
  @JsonKey(ignore: true)
  _$$DynamicFirstCopyWith<_$DynamicFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CustomListEqual {
  CustomList<int> get list => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CustomListEqualCopyWith<CustomListEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomListEqualCopyWith<$Res> {
  factory $CustomListEqualCopyWith(
          CustomListEqual value, $Res Function(CustomListEqual) then) =
      _$CustomListEqualCopyWithImpl<$Res, CustomListEqual>;
  @useResult
  $Res call({CustomList<int> list});
}

/// @nodoc
class _$CustomListEqualCopyWithImpl<$Res, $Val extends CustomListEqual>
    implements $CustomListEqualCopyWith<$Res> {
  _$CustomListEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as CustomList<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CustomListEqualFirstCopyWith<$Res>
    implements $CustomListEqualCopyWith<$Res> {
  factory _$$CustomListEqualFirstCopyWith(_$CustomListEqualFirst value,
          $Res Function(_$CustomListEqualFirst) then) =
      __$$CustomListEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({CustomList<int> list});
}

/// @nodoc
class __$$CustomListEqualFirstCopyWithImpl<$Res>
    extends _$CustomListEqualCopyWithImpl<$Res, _$CustomListEqualFirst>
    implements _$$CustomListEqualFirstCopyWith<$Res> {
  __$$CustomListEqualFirstCopyWithImpl(_$CustomListEqualFirst _value,
      $Res Function(_$CustomListEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_$CustomListEqualFirst(
      null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as CustomList<int>,
    ));
  }
}

/// @nodoc

class _$CustomListEqualFirst implements CustomListEqualFirst {
  _$CustomListEqualFirst(this.list);

  @override
  final CustomList<int> list;

  @override
  String toString() {
    return 'CustomListEqual(list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomListEqualFirst &&
            const DeepCollectionEquality().equals(other.list, list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomListEqualFirstCopyWith<_$CustomListEqualFirst> get copyWith =>
      __$$CustomListEqualFirstCopyWithImpl<_$CustomListEqualFirst>(
          this, _$identity);
}

abstract class CustomListEqualFirst implements CustomListEqual {
  factory CustomListEqualFirst(final CustomList<int> list) =
      _$CustomListEqualFirst;

  @override
  CustomList<int> get list;
  @override
  @JsonKey(ignore: true)
  _$$CustomListEqualFirstCopyWith<_$CustomListEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ListEqual {
  List<int> get list => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ListEqualCopyWith<ListEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListEqualCopyWith<$Res> {
  factory $ListEqualCopyWith(ListEqual value, $Res Function(ListEqual) then) =
      _$ListEqualCopyWithImpl<$Res, ListEqual>;
  @useResult
  $Res call({List<int> list});
}

/// @nodoc
class _$ListEqualCopyWithImpl<$Res, $Val extends ListEqual>
    implements $ListEqualCopyWith<$Res> {
  _$ListEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ListEqualFirstCopyWith<$Res>
    implements $ListEqualCopyWith<$Res> {
  factory _$$ListEqualFirstCopyWith(
          _$ListEqualFirst value, $Res Function(_$ListEqualFirst) then) =
      __$$ListEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<int> list});
}

/// @nodoc
class __$$ListEqualFirstCopyWithImpl<$Res>
    extends _$ListEqualCopyWithImpl<$Res, _$ListEqualFirst>
    implements _$$ListEqualFirstCopyWith<$Res> {
  __$$ListEqualFirstCopyWithImpl(
      _$ListEqualFirst _value, $Res Function(_$ListEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_$ListEqualFirst(
      null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$ListEqualFirst implements ListEqualFirst {
  _$ListEqualFirst(this.list);

  @override
  final List<int> list;

  @override
  String toString() {
    return 'ListEqual(list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListEqualFirst &&
            const DeepCollectionEquality().equals(other.list, list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListEqualFirstCopyWith<_$ListEqualFirst> get copyWith =>
      __$$ListEqualFirstCopyWithImpl<_$ListEqualFirst>(this, _$identity);
}

abstract class ListEqualFirst implements ListEqual {
  factory ListEqualFirst(final List<int> list) = _$ListEqualFirst;

  @override
  List<int> get list;
  @override
  @JsonKey(ignore: true)
  _$$ListEqualFirstCopyWith<_$ListEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnmodifiableListEqual {
  List<int> get list => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnmodifiableListEqualCopyWith<UnmodifiableListEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnmodifiableListEqualCopyWith<$Res> {
  factory $UnmodifiableListEqualCopyWith(UnmodifiableListEqual value,
          $Res Function(UnmodifiableListEqual) then) =
      _$UnmodifiableListEqualCopyWithImpl<$Res, UnmodifiableListEqual>;
  @useResult
  $Res call({List<int> list});
}

/// @nodoc
class _$UnmodifiableListEqualCopyWithImpl<$Res,
        $Val extends UnmodifiableListEqual>
    implements $UnmodifiableListEqualCopyWith<$Res> {
  _$UnmodifiableListEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_value.copyWith(
      list: null == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UnmodifiableListEqualFirstCopyWith<$Res>
    implements $UnmodifiableListEqualCopyWith<$Res> {
  factory _$$UnmodifiableListEqualFirstCopyWith(
          _$UnmodifiableListEqualFirst value,
          $Res Function(_$UnmodifiableListEqualFirst) then) =
      __$$UnmodifiableListEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<int> list});
}

/// @nodoc
class __$$UnmodifiableListEqualFirstCopyWithImpl<$Res>
    extends _$UnmodifiableListEqualCopyWithImpl<$Res,
        _$UnmodifiableListEqualFirst>
    implements _$$UnmodifiableListEqualFirstCopyWith<$Res> {
  __$$UnmodifiableListEqualFirstCopyWithImpl(
      _$UnmodifiableListEqualFirst _value,
      $Res Function(_$UnmodifiableListEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = null,
  }) {
    return _then(_$UnmodifiableListEqualFirst(
      null == list
          ? _value._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$UnmodifiableListEqualFirst implements UnmodifiableListEqualFirst {
  _$UnmodifiableListEqualFirst(final List<int> list) : _list = list;

  final List<int> _list;
  @override
  List<int> get list {
    if (_list is EqualUnmodifiableListView) return _list;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_list);
  }

  @override
  String toString() {
    return 'UnmodifiableListEqual(list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnmodifiableListEqualFirst &&
            const DeepCollectionEquality().equals(other._list, _list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnmodifiableListEqualFirstCopyWith<_$UnmodifiableListEqualFirst>
      get copyWith => __$$UnmodifiableListEqualFirstCopyWithImpl<
          _$UnmodifiableListEqualFirst>(this, _$identity);
}

abstract class UnmodifiableListEqualFirst implements UnmodifiableListEqual {
  factory UnmodifiableListEqualFirst(final List<int> list) =
      _$UnmodifiableListEqualFirst;

  @override
  List<int> get list;
  @override
  @JsonKey(ignore: true)
  _$$UnmodifiableListEqualFirstCopyWith<_$UnmodifiableListEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullUnmodifiableListEqual {
  List<int>? get list => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NullUnmodifiableListEqualCopyWith<NullUnmodifiableListEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullUnmodifiableListEqualCopyWith<$Res> {
  factory $NullUnmodifiableListEqualCopyWith(NullUnmodifiableListEqual value,
          $Res Function(NullUnmodifiableListEqual) then) =
      _$NullUnmodifiableListEqualCopyWithImpl<$Res, NullUnmodifiableListEqual>;
  @useResult
  $Res call({List<int>? list});
}

/// @nodoc
class _$NullUnmodifiableListEqualCopyWithImpl<$Res,
        $Val extends NullUnmodifiableListEqual>
    implements $NullUnmodifiableListEqualCopyWith<$Res> {
  _$NullUnmodifiableListEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = freezed,
  }) {
    return _then(_value.copyWith(
      list: freezed == list
          ? _value.list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NullUnmodifiableListEqualFirstCopyWith<$Res>
    implements $NullUnmodifiableListEqualCopyWith<$Res> {
  factory _$$NullUnmodifiableListEqualFirstCopyWith(
          _$NullUnmodifiableListEqualFirst value,
          $Res Function(_$NullUnmodifiableListEqualFirst) then) =
      __$$NullUnmodifiableListEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<int>? list});
}

/// @nodoc
class __$$NullUnmodifiableListEqualFirstCopyWithImpl<$Res>
    extends _$NullUnmodifiableListEqualCopyWithImpl<$Res,
        _$NullUnmodifiableListEqualFirst>
    implements _$$NullUnmodifiableListEqualFirstCopyWith<$Res> {
  __$$NullUnmodifiableListEqualFirstCopyWithImpl(
      _$NullUnmodifiableListEqualFirst _value,
      $Res Function(_$NullUnmodifiableListEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? list = freezed,
  }) {
    return _then(_$NullUnmodifiableListEqualFirst(
      freezed == list
          ? _value._list
          : list // ignore: cast_nullable_to_non_nullable
              as List<int>?,
    ));
  }
}

/// @nodoc

class _$NullUnmodifiableListEqualFirst
    implements NullUnmodifiableListEqualFirst {
  _$NullUnmodifiableListEqualFirst(final List<int>? list) : _list = list;

  final List<int>? _list;
  @override
  List<int>? get list {
    final value = _list;
    if (value == null) return null;
    if (_list is EqualUnmodifiableListView) return _list;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'NullUnmodifiableListEqual(list: $list)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullUnmodifiableListEqualFirst &&
            const DeepCollectionEquality().equals(other._list, _list));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_list));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullUnmodifiableListEqualFirstCopyWith<_$NullUnmodifiableListEqualFirst>
      get copyWith => __$$NullUnmodifiableListEqualFirstCopyWithImpl<
          _$NullUnmodifiableListEqualFirst>(this, _$identity);
}

abstract class NullUnmodifiableListEqualFirst
    implements NullUnmodifiableListEqual {
  factory NullUnmodifiableListEqualFirst(final List<int>? list) =
      _$NullUnmodifiableListEqualFirst;

  @override
  List<int>? get list;
  @override
  @JsonKey(ignore: true)
  _$$NullUnmodifiableListEqualFirstCopyWith<_$NullUnmodifiableListEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CustomSetEqual {
  CustomSet<int> get dartSet => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CustomSetEqualCopyWith<CustomSetEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomSetEqualCopyWith<$Res> {
  factory $CustomSetEqualCopyWith(
          CustomSetEqual value, $Res Function(CustomSetEqual) then) =
      _$CustomSetEqualCopyWithImpl<$Res, CustomSetEqual>;
  @useResult
  $Res call({CustomSet<int> dartSet});
}

/// @nodoc
class _$CustomSetEqualCopyWithImpl<$Res, $Val extends CustomSetEqual>
    implements $CustomSetEqualCopyWith<$Res> {
  _$CustomSetEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_value.copyWith(
      dartSet: null == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as CustomSet<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CustomSetEqualFirstCopyWith<$Res>
    implements $CustomSetEqualCopyWith<$Res> {
  factory _$$CustomSetEqualFirstCopyWith(_$CustomSetEqualFirst value,
          $Res Function(_$CustomSetEqualFirst) then) =
      __$$CustomSetEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({CustomSet<int> dartSet});
}

/// @nodoc
class __$$CustomSetEqualFirstCopyWithImpl<$Res>
    extends _$CustomSetEqualCopyWithImpl<$Res, _$CustomSetEqualFirst>
    implements _$$CustomSetEqualFirstCopyWith<$Res> {
  __$$CustomSetEqualFirstCopyWithImpl(
      _$CustomSetEqualFirst _value, $Res Function(_$CustomSetEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_$CustomSetEqualFirst(
      null == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as CustomSet<int>,
    ));
  }
}

/// @nodoc

class _$CustomSetEqualFirst implements CustomSetEqualFirst {
  _$CustomSetEqualFirst(this.dartSet);

  @override
  final CustomSet<int> dartSet;

  @override
  String toString() {
    return 'CustomSetEqual(dartSet: $dartSet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomSetEqualFirst &&
            const DeepCollectionEquality().equals(other.dartSet, dartSet));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(dartSet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomSetEqualFirstCopyWith<_$CustomSetEqualFirst> get copyWith =>
      __$$CustomSetEqualFirstCopyWithImpl<_$CustomSetEqualFirst>(
          this, _$identity);
}

abstract class CustomSetEqualFirst implements CustomSetEqual {
  factory CustomSetEqualFirst(final CustomSet<int> dartSet) =
      _$CustomSetEqualFirst;

  @override
  CustomSet<int> get dartSet;
  @override
  @JsonKey(ignore: true)
  _$$CustomSetEqualFirstCopyWith<_$CustomSetEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SetEqual {
  Set<int> get dartSet => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetEqualCopyWith<SetEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetEqualCopyWith<$Res> {
  factory $SetEqualCopyWith(SetEqual value, $Res Function(SetEqual) then) =
      _$SetEqualCopyWithImpl<$Res, SetEqual>;
  @useResult
  $Res call({Set<int> dartSet});
}

/// @nodoc
class _$SetEqualCopyWithImpl<$Res, $Val extends SetEqual>
    implements $SetEqualCopyWith<$Res> {
  _$SetEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_value.copyWith(
      dartSet: null == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SetEqualFirstCopyWith<$Res>
    implements $SetEqualCopyWith<$Res> {
  factory _$$SetEqualFirstCopyWith(
          _$SetEqualFirst value, $Res Function(_$SetEqualFirst) then) =
      __$$SetEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Set<int> dartSet});
}

/// @nodoc
class __$$SetEqualFirstCopyWithImpl<$Res>
    extends _$SetEqualCopyWithImpl<$Res, _$SetEqualFirst>
    implements _$$SetEqualFirstCopyWith<$Res> {
  __$$SetEqualFirstCopyWithImpl(
      _$SetEqualFirst _value, $Res Function(_$SetEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_$SetEqualFirst(
      null == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc

class _$SetEqualFirst implements SetEqualFirst {
  _$SetEqualFirst(this.dartSet);

  @override
  final Set<int> dartSet;

  @override
  String toString() {
    return 'SetEqual(dartSet: $dartSet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetEqualFirst &&
            const DeepCollectionEquality().equals(other.dartSet, dartSet));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(dartSet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SetEqualFirstCopyWith<_$SetEqualFirst> get copyWith =>
      __$$SetEqualFirstCopyWithImpl<_$SetEqualFirst>(this, _$identity);
}

abstract class SetEqualFirst implements SetEqual {
  factory SetEqualFirst(final Set<int> dartSet) = _$SetEqualFirst;

  @override
  Set<int> get dartSet;
  @override
  @JsonKey(ignore: true)
  _$$SetEqualFirstCopyWith<_$SetEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnmodifiableSetEqual {
  Set<int> get dartSet => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnmodifiableSetEqualCopyWith<UnmodifiableSetEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnmodifiableSetEqualCopyWith<$Res> {
  factory $UnmodifiableSetEqualCopyWith(UnmodifiableSetEqual value,
          $Res Function(UnmodifiableSetEqual) then) =
      _$UnmodifiableSetEqualCopyWithImpl<$Res, UnmodifiableSetEqual>;
  @useResult
  $Res call({Set<int> dartSet});
}

/// @nodoc
class _$UnmodifiableSetEqualCopyWithImpl<$Res,
        $Val extends UnmodifiableSetEqual>
    implements $UnmodifiableSetEqualCopyWith<$Res> {
  _$UnmodifiableSetEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_value.copyWith(
      dartSet: null == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UnmodifiableSetEqualFirstCopyWith<$Res>
    implements $UnmodifiableSetEqualCopyWith<$Res> {
  factory _$$UnmodifiableSetEqualFirstCopyWith(
          _$UnmodifiableSetEqualFirst value,
          $Res Function(_$UnmodifiableSetEqualFirst) then) =
      __$$UnmodifiableSetEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Set<int> dartSet});
}

/// @nodoc
class __$$UnmodifiableSetEqualFirstCopyWithImpl<$Res>
    extends _$UnmodifiableSetEqualCopyWithImpl<$Res,
        _$UnmodifiableSetEqualFirst>
    implements _$$UnmodifiableSetEqualFirstCopyWith<$Res> {
  __$$UnmodifiableSetEqualFirstCopyWithImpl(_$UnmodifiableSetEqualFirst _value,
      $Res Function(_$UnmodifiableSetEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = null,
  }) {
    return _then(_$UnmodifiableSetEqualFirst(
      null == dartSet
          ? _value._dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc

class _$UnmodifiableSetEqualFirst implements UnmodifiableSetEqualFirst {
  _$UnmodifiableSetEqualFirst(final Set<int> dartSet) : _dartSet = dartSet;

  final Set<int> _dartSet;
  @override
  Set<int> get dartSet {
    if (_dartSet is EqualUnmodifiableSetView) return _dartSet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_dartSet);
  }

  @override
  String toString() {
    return 'UnmodifiableSetEqual(dartSet: $dartSet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnmodifiableSetEqualFirst &&
            const DeepCollectionEquality().equals(other._dartSet, _dartSet));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_dartSet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnmodifiableSetEqualFirstCopyWith<_$UnmodifiableSetEqualFirst>
      get copyWith => __$$UnmodifiableSetEqualFirstCopyWithImpl<
          _$UnmodifiableSetEqualFirst>(this, _$identity);
}

abstract class UnmodifiableSetEqualFirst implements UnmodifiableSetEqual {
  factory UnmodifiableSetEqualFirst(final Set<int> dartSet) =
      _$UnmodifiableSetEqualFirst;

  @override
  Set<int> get dartSet;
  @override
  @JsonKey(ignore: true)
  _$$UnmodifiableSetEqualFirstCopyWith<_$UnmodifiableSetEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullUnmodifiableSetEqual {
  Set<int>? get dartSet => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NullUnmodifiableSetEqualCopyWith<NullUnmodifiableSetEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullUnmodifiableSetEqualCopyWith<$Res> {
  factory $NullUnmodifiableSetEqualCopyWith(NullUnmodifiableSetEqual value,
          $Res Function(NullUnmodifiableSetEqual) then) =
      _$NullUnmodifiableSetEqualCopyWithImpl<$Res, NullUnmodifiableSetEqual>;
  @useResult
  $Res call({Set<int>? dartSet});
}

/// @nodoc
class _$NullUnmodifiableSetEqualCopyWithImpl<$Res,
        $Val extends NullUnmodifiableSetEqual>
    implements $NullUnmodifiableSetEqualCopyWith<$Res> {
  _$NullUnmodifiableSetEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = freezed,
  }) {
    return _then(_value.copyWith(
      dartSet: freezed == dartSet
          ? _value.dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NullUnmodifiableSetEqualFirstCopyWith<$Res>
    implements $NullUnmodifiableSetEqualCopyWith<$Res> {
  factory _$$NullUnmodifiableSetEqualFirstCopyWith(
          _$NullUnmodifiableSetEqualFirst value,
          $Res Function(_$NullUnmodifiableSetEqualFirst) then) =
      __$$NullUnmodifiableSetEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Set<int>? dartSet});
}

/// @nodoc
class __$$NullUnmodifiableSetEqualFirstCopyWithImpl<$Res>
    extends _$NullUnmodifiableSetEqualCopyWithImpl<$Res,
        _$NullUnmodifiableSetEqualFirst>
    implements _$$NullUnmodifiableSetEqualFirstCopyWith<$Res> {
  __$$NullUnmodifiableSetEqualFirstCopyWithImpl(
      _$NullUnmodifiableSetEqualFirst _value,
      $Res Function(_$NullUnmodifiableSetEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dartSet = freezed,
  }) {
    return _then(_$NullUnmodifiableSetEqualFirst(
      freezed == dartSet
          ? _value._dartSet
          : dartSet // ignore: cast_nullable_to_non_nullable
              as Set<int>?,
    ));
  }
}

/// @nodoc

class _$NullUnmodifiableSetEqualFirst implements NullUnmodifiableSetEqualFirst {
  _$NullUnmodifiableSetEqualFirst(final Set<int>? dartSet) : _dartSet = dartSet;

  final Set<int>? _dartSet;
  @override
  Set<int>? get dartSet {
    final value = _dartSet;
    if (value == null) return null;
    if (_dartSet is EqualUnmodifiableSetView) return _dartSet;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(value);
  }

  @override
  String toString() {
    return 'NullUnmodifiableSetEqual(dartSet: $dartSet)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullUnmodifiableSetEqualFirst &&
            const DeepCollectionEquality().equals(other._dartSet, _dartSet));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_dartSet));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullUnmodifiableSetEqualFirstCopyWith<_$NullUnmodifiableSetEqualFirst>
      get copyWith => __$$NullUnmodifiableSetEqualFirstCopyWithImpl<
          _$NullUnmodifiableSetEqualFirst>(this, _$identity);
}

abstract class NullUnmodifiableSetEqualFirst
    implements NullUnmodifiableSetEqual {
  factory NullUnmodifiableSetEqualFirst(final Set<int>? dartSet) =
      _$NullUnmodifiableSetEqualFirst;

  @override
  Set<int>? get dartSet;
  @override
  @JsonKey(ignore: true)
  _$$NullUnmodifiableSetEqualFirstCopyWith<_$NullUnmodifiableSetEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CustomMapEqual {
  CustomMap<String, Object?> get map => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $CustomMapEqualCopyWith<CustomMapEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CustomMapEqualCopyWith<$Res> {
  factory $CustomMapEqualCopyWith(
          CustomMapEqual value, $Res Function(CustomMapEqual) then) =
      _$CustomMapEqualCopyWithImpl<$Res, CustomMapEqual>;
  @useResult
  $Res call({CustomMap<String, Object?> map});
}

/// @nodoc
class _$CustomMapEqualCopyWithImpl<$Res, $Val extends CustomMapEqual>
    implements $CustomMapEqualCopyWith<$Res> {
  _$CustomMapEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_value.copyWith(
      map: null == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as CustomMap<String, Object?>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CustomMapEqualFirstCopyWith<$Res>
    implements $CustomMapEqualCopyWith<$Res> {
  factory _$$CustomMapEqualFirstCopyWith(_$CustomMapEqualFirst value,
          $Res Function(_$CustomMapEqualFirst) then) =
      __$$CustomMapEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({CustomMap<String, Object?> map});
}

/// @nodoc
class __$$CustomMapEqualFirstCopyWithImpl<$Res>
    extends _$CustomMapEqualCopyWithImpl<$Res, _$CustomMapEqualFirst>
    implements _$$CustomMapEqualFirstCopyWith<$Res> {
  __$$CustomMapEqualFirstCopyWithImpl(
      _$CustomMapEqualFirst _value, $Res Function(_$CustomMapEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_$CustomMapEqualFirst(
      null == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as CustomMap<String, Object?>,
    ));
  }
}

/// @nodoc

class _$CustomMapEqualFirst implements CustomMapEqualFirst {
  _$CustomMapEqualFirst(this.map);

  @override
  final CustomMap<String, Object?> map;

  @override
  String toString() {
    return 'CustomMapEqual(map: $map)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CustomMapEqualFirst &&
            const DeepCollectionEquality().equals(other.map, map));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(map));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$CustomMapEqualFirstCopyWith<_$CustomMapEqualFirst> get copyWith =>
      __$$CustomMapEqualFirstCopyWithImpl<_$CustomMapEqualFirst>(
          this, _$identity);
}

abstract class CustomMapEqualFirst implements CustomMapEqual {
  factory CustomMapEqualFirst(final CustomMap<String, Object?> map) =
      _$CustomMapEqualFirst;

  @override
  CustomMap<String, Object?> get map;
  @override
  @JsonKey(ignore: true)
  _$$CustomMapEqualFirstCopyWith<_$CustomMapEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MapEqual {
  Map<String, Object?> get map => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MapEqualCopyWith<MapEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapEqualCopyWith<$Res> {
  factory $MapEqualCopyWith(MapEqual value, $Res Function(MapEqual) then) =
      _$MapEqualCopyWithImpl<$Res, MapEqual>;
  @useResult
  $Res call({Map<String, Object?> map});
}

/// @nodoc
class _$MapEqualCopyWithImpl<$Res, $Val extends MapEqual>
    implements $MapEqualCopyWith<$Res> {
  _$MapEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_value.copyWith(
      map: null == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MapEqualFirstCopyWith<$Res>
    implements $MapEqualCopyWith<$Res> {
  factory _$$MapEqualFirstCopyWith(
          _$MapEqualFirst value, $Res Function(_$MapEqualFirst) then) =
      __$$MapEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, Object?> map});
}

/// @nodoc
class __$$MapEqualFirstCopyWithImpl<$Res>
    extends _$MapEqualCopyWithImpl<$Res, _$MapEqualFirst>
    implements _$$MapEqualFirstCopyWith<$Res> {
  __$$MapEqualFirstCopyWithImpl(
      _$MapEqualFirst _value, $Res Function(_$MapEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_$MapEqualFirst(
      null == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>,
    ));
  }
}

/// @nodoc

class _$MapEqualFirst implements MapEqualFirst {
  _$MapEqualFirst(this.map);

  @override
  final Map<String, Object?> map;

  @override
  String toString() {
    return 'MapEqual(map: $map)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MapEqualFirst &&
            const DeepCollectionEquality().equals(other.map, map));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(map));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MapEqualFirstCopyWith<_$MapEqualFirst> get copyWith =>
      __$$MapEqualFirstCopyWithImpl<_$MapEqualFirst>(this, _$identity);
}

abstract class MapEqualFirst implements MapEqual {
  factory MapEqualFirst(final Map<String, Object?> map) = _$MapEqualFirst;

  @override
  Map<String, Object?> get map;
  @override
  @JsonKey(ignore: true)
  _$$MapEqualFirstCopyWith<_$MapEqualFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnmodifiableMapEqual {
  Map<String, Object?> get map => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnmodifiableMapEqualCopyWith<UnmodifiableMapEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnmodifiableMapEqualCopyWith<$Res> {
  factory $UnmodifiableMapEqualCopyWith(UnmodifiableMapEqual value,
          $Res Function(UnmodifiableMapEqual) then) =
      _$UnmodifiableMapEqualCopyWithImpl<$Res, UnmodifiableMapEqual>;
  @useResult
  $Res call({Map<String, Object?> map});
}

/// @nodoc
class _$UnmodifiableMapEqualCopyWithImpl<$Res,
        $Val extends UnmodifiableMapEqual>
    implements $UnmodifiableMapEqualCopyWith<$Res> {
  _$UnmodifiableMapEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_value.copyWith(
      map: null == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$UnmodifiableMapEqualFirstCopyWith<$Res>
    implements $UnmodifiableMapEqualCopyWith<$Res> {
  factory _$$UnmodifiableMapEqualFirstCopyWith(
          _$UnmodifiableMapEqualFirst value,
          $Res Function(_$UnmodifiableMapEqualFirst) then) =
      __$$UnmodifiableMapEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, Object?> map});
}

/// @nodoc
class __$$UnmodifiableMapEqualFirstCopyWithImpl<$Res>
    extends _$UnmodifiableMapEqualCopyWithImpl<$Res,
        _$UnmodifiableMapEqualFirst>
    implements _$$UnmodifiableMapEqualFirstCopyWith<$Res> {
  __$$UnmodifiableMapEqualFirstCopyWithImpl(_$UnmodifiableMapEqualFirst _value,
      $Res Function(_$UnmodifiableMapEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = null,
  }) {
    return _then(_$UnmodifiableMapEqualFirst(
      null == map
          ? _value._map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>,
    ));
  }
}

/// @nodoc

class _$UnmodifiableMapEqualFirst implements UnmodifiableMapEqualFirst {
  _$UnmodifiableMapEqualFirst(final Map<String, Object?> map) : _map = map;

  final Map<String, Object?> _map;
  @override
  Map<String, Object?> get map {
    if (_map is EqualUnmodifiableMapView) return _map;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_map);
  }

  @override
  String toString() {
    return 'UnmodifiableMapEqual(map: $map)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UnmodifiableMapEqualFirst &&
            const DeepCollectionEquality().equals(other._map, _map));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_map));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$UnmodifiableMapEqualFirstCopyWith<_$UnmodifiableMapEqualFirst>
      get copyWith => __$$UnmodifiableMapEqualFirstCopyWithImpl<
          _$UnmodifiableMapEqualFirst>(this, _$identity);
}

abstract class UnmodifiableMapEqualFirst implements UnmodifiableMapEqual {
  factory UnmodifiableMapEqualFirst(final Map<String, Object?> map) =
      _$UnmodifiableMapEqualFirst;

  @override
  Map<String, Object?> get map;
  @override
  @JsonKey(ignore: true)
  _$$UnmodifiableMapEqualFirstCopyWith<_$UnmodifiableMapEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullUnmodifiableMapEqual {
  Map<String, Object?>? get map => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NullUnmodifiableMapEqualCopyWith<NullUnmodifiableMapEqual> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullUnmodifiableMapEqualCopyWith<$Res> {
  factory $NullUnmodifiableMapEqualCopyWith(NullUnmodifiableMapEqual value,
          $Res Function(NullUnmodifiableMapEqual) then) =
      _$NullUnmodifiableMapEqualCopyWithImpl<$Res, NullUnmodifiableMapEqual>;
  @useResult
  $Res call({Map<String, Object?>? map});
}

/// @nodoc
class _$NullUnmodifiableMapEqualCopyWithImpl<$Res,
        $Val extends NullUnmodifiableMapEqual>
    implements $NullUnmodifiableMapEqualCopyWith<$Res> {
  _$NullUnmodifiableMapEqualCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = freezed,
  }) {
    return _then(_value.copyWith(
      map: freezed == map
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NullUnmodifiableMapEqualFirstCopyWith<$Res>
    implements $NullUnmodifiableMapEqualCopyWith<$Res> {
  factory _$$NullUnmodifiableMapEqualFirstCopyWith(
          _$NullUnmodifiableMapEqualFirst value,
          $Res Function(_$NullUnmodifiableMapEqualFirst) then) =
      __$$NullUnmodifiableMapEqualFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<String, Object?>? map});
}

/// @nodoc
class __$$NullUnmodifiableMapEqualFirstCopyWithImpl<$Res>
    extends _$NullUnmodifiableMapEqualCopyWithImpl<$Res,
        _$NullUnmodifiableMapEqualFirst>
    implements _$$NullUnmodifiableMapEqualFirstCopyWith<$Res> {
  __$$NullUnmodifiableMapEqualFirstCopyWithImpl(
      _$NullUnmodifiableMapEqualFirst _value,
      $Res Function(_$NullUnmodifiableMapEqualFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? map = freezed,
  }) {
    return _then(_$NullUnmodifiableMapEqualFirst(
      freezed == map
          ? _value._map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<String, Object?>?,
    ));
  }
}

/// @nodoc

class _$NullUnmodifiableMapEqualFirst implements NullUnmodifiableMapEqualFirst {
  _$NullUnmodifiableMapEqualFirst(final Map<String, Object?>? map) : _map = map;

  final Map<String, Object?>? _map;
  @override
  Map<String, Object?>? get map {
    final value = _map;
    if (value == null) return null;
    if (_map is EqualUnmodifiableMapView) return _map;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  @override
  String toString() {
    return 'NullUnmodifiableMapEqual(map: $map)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NullUnmodifiableMapEqualFirst &&
            const DeepCollectionEquality().equals(other._map, _map));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_map));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$NullUnmodifiableMapEqualFirstCopyWith<_$NullUnmodifiableMapEqualFirst>
      get copyWith => __$$NullUnmodifiableMapEqualFirstCopyWithImpl<
          _$NullUnmodifiableMapEqualFirst>(this, _$identity);
}

abstract class NullUnmodifiableMapEqualFirst
    implements NullUnmodifiableMapEqual {
  factory NullUnmodifiableMapEqualFirst(final Map<String, Object?>? map) =
      _$NullUnmodifiableMapEqualFirst;

  @override
  Map<String, Object?>? get map;
  @override
  @JsonKey(ignore: true)
  _$$NullUnmodifiableMapEqualFirstCopyWith<_$NullUnmodifiableMapEqualFirst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WithAlias {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? first,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WithAliasFirst value) first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WithAliasFirst value)? first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WithAliasFirst value)? first,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WithAliasCopyWith<$Res> {
  factory $WithAliasCopyWith(WithAlias value, $Res Function(WithAlias) then) =
      _$WithAliasCopyWithImpl<$Res, WithAlias>;
}

/// @nodoc
class _$WithAliasCopyWithImpl<$Res, $Val extends WithAlias>
    implements $WithAliasCopyWith<$Res> {
  _$WithAliasCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WithAliasFirstCopyWith<$Res> {
  factory _$$WithAliasFirstCopyWith(
          _$WithAliasFirst value, $Res Function(_$WithAliasFirst) then) =
      __$$WithAliasFirstCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WithAliasFirstCopyWithImpl<$Res>
    extends _$WithAliasCopyWithImpl<$Res, _$WithAliasFirst>
    implements _$$WithAliasFirstCopyWith<$Res> {
  __$$WithAliasFirstCopyWithImpl(
      _$WithAliasFirst _value, $Res Function(_$WithAliasFirst) _then)
      : super(_value, _then);
}

/// @nodoc

@withAlias
class _$WithAliasFirst with Some<Complex<Type>> implements WithAliasFirst {
  _$WithAliasFirst();

  @override
  String toString() {
    return 'WithAlias.first()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WithAliasFirst);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() first,
  }) {
    return first();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? first,
  }) {
    return first?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? first,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WithAliasFirst value) first,
  }) {
    return first(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WithAliasFirst value)? first,
  }) {
    return first?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WithAliasFirst value)? first,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(this);
    }
    return orElse();
  }
}

abstract class WithAliasFirst implements WithAlias, Some<Complex<Type>> {
  factory WithAliasFirst() = _$WithAliasFirst;
}

/// @nodoc
mixin _$ImplementsAlias {
  Complex<Type>? get value => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Complex<Type>? value) first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Complex<Type>? value)? first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Complex<Type>? value)? first,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ImplementsAliasFirst value) first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ImplementsAliasFirst value)? first,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ImplementsAliasFirst value)? first,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ImplementsAliasCopyWith<ImplementsAlias> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImplementsAliasCopyWith<$Res> {
  factory $ImplementsAliasCopyWith(
          ImplementsAlias value, $Res Function(ImplementsAlias) then) =
      _$ImplementsAliasCopyWithImpl<$Res, ImplementsAlias>;
  @useResult
  $Res call({Complex<Type>? value});
}

/// @nodoc
class _$ImplementsAliasCopyWithImpl<$Res, $Val extends ImplementsAlias>
    implements $ImplementsAliasCopyWith<$Res> {
  _$ImplementsAliasCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Complex<Type>?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImplementsAliasFirstCopyWith<$Res>
    implements $ImplementsAliasCopyWith<$Res> {
  factory _$$ImplementsAliasFirstCopyWith(_$ImplementsAliasFirst value,
          $Res Function(_$ImplementsAliasFirst) then) =
      __$$ImplementsAliasFirstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Complex<Type>? value});
}

/// @nodoc
class __$$ImplementsAliasFirstCopyWithImpl<$Res>
    extends _$ImplementsAliasCopyWithImpl<$Res, _$ImplementsAliasFirst>
    implements _$$ImplementsAliasFirstCopyWith<$Res> {
  __$$ImplementsAliasFirstCopyWithImpl(_$ImplementsAliasFirst _value,
      $Res Function(_$ImplementsAliasFirst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$ImplementsAliasFirst(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Complex<Type>?,
    ));
  }
}

/// @nodoc

@implementsAlias
class _$ImplementsAliasFirst implements ImplementsAliasFirst {
  _$ImplementsAliasFirst({this.value});

  @override
  final Complex<Type>? value;

  @override
  String toString() {
    return 'ImplementsAlias.first(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImplementsAliasFirst &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImplementsAliasFirstCopyWith<_$ImplementsAliasFirst> get copyWith =>
      __$$ImplementsAliasFirstCopyWithImpl<_$ImplementsAliasFirst>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Complex<Type>? value) first,
  }) {
    return first(value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Complex<Type>? value)? first,
  }) {
    return first?.call(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Complex<Type>? value)? first,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ImplementsAliasFirst value) first,
  }) {
    return first(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ImplementsAliasFirst value)? first,
  }) {
    return first?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ImplementsAliasFirst value)? first,
    required TResult orElse(),
  }) {
    if (first != null) {
      return first(this);
    }
    return orElse();
  }
}

abstract class ImplementsAliasFirst
    implements ImplementsAlias, Some<Complex<Type>> {
  factory ImplementsAliasFirst({final Complex<Type>? value}) =
      _$ImplementsAliasFirst;

  @override
  Complex<Type>? get value;
  @override
  @JsonKey(ignore: true)
  _$$ImplementsAliasFirstCopyWith<_$ImplementsAliasFirst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Large {
  int? get a0 => throw _privateConstructorUsedError;
  int? get a1 => throw _privateConstructorUsedError;
  int? get a2 => throw _privateConstructorUsedError;
  int? get a3 => throw _privateConstructorUsedError;
  int? get a4 => throw _privateConstructorUsedError;
  int? get a5 => throw _privateConstructorUsedError;
  int? get a6 => throw _privateConstructorUsedError;
  int? get a7 => throw _privateConstructorUsedError;
  int? get a8 => throw _privateConstructorUsedError;
  int? get a9 => throw _privateConstructorUsedError;
  int? get a10 => throw _privateConstructorUsedError;
  int? get a11 => throw _privateConstructorUsedError;
  int? get a12 => throw _privateConstructorUsedError;
  int? get a13 => throw _privateConstructorUsedError;
  int? get a14 => throw _privateConstructorUsedError;
  int? get a15 => throw _privateConstructorUsedError;
  int? get a16 => throw _privateConstructorUsedError;
  int? get a17 => throw _privateConstructorUsedError;
  int? get a18 => throw _privateConstructorUsedError;
  int? get a19 => throw _privateConstructorUsedError;
  int? get a20 => throw _privateConstructorUsedError;
  int? get a21 => throw _privateConstructorUsedError;
  int? get a22 => throw _privateConstructorUsedError;
  int? get a23 => throw _privateConstructorUsedError;
  int? get a24 => throw _privateConstructorUsedError;
  int? get a25 => throw _privateConstructorUsedError;
  int? get a26 => throw _privateConstructorUsedError;
  int? get a27 => throw _privateConstructorUsedError;
  int? get a28 => throw _privateConstructorUsedError;
  int? get a29 => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LargeCopyWith<Large> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LargeCopyWith<$Res> {
  factory $LargeCopyWith(Large value, $Res Function(Large) then) =
      _$LargeCopyWithImpl<$Res, Large>;
  @useResult
  $Res call(
      {int? a0,
      int? a1,
      int? a2,
      int? a3,
      int? a4,
      int? a5,
      int? a6,
      int? a7,
      int? a8,
      int? a9,
      int? a10,
      int? a11,
      int? a12,
      int? a13,
      int? a14,
      int? a15,
      int? a16,
      int? a17,
      int? a18,
      int? a19,
      int? a20,
      int? a21,
      int? a22,
      int? a23,
      int? a24,
      int? a25,
      int? a26,
      int? a27,
      int? a28,
      int? a29});
}

/// @nodoc
class _$LargeCopyWithImpl<$Res, $Val extends Large>
    implements $LargeCopyWith<$Res> {
  _$LargeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a0 = freezed,
    Object? a1 = freezed,
    Object? a2 = freezed,
    Object? a3 = freezed,
    Object? a4 = freezed,
    Object? a5 = freezed,
    Object? a6 = freezed,
    Object? a7 = freezed,
    Object? a8 = freezed,
    Object? a9 = freezed,
    Object? a10 = freezed,
    Object? a11 = freezed,
    Object? a12 = freezed,
    Object? a13 = freezed,
    Object? a14 = freezed,
    Object? a15 = freezed,
    Object? a16 = freezed,
    Object? a17 = freezed,
    Object? a18 = freezed,
    Object? a19 = freezed,
    Object? a20 = freezed,
    Object? a21 = freezed,
    Object? a22 = freezed,
    Object? a23 = freezed,
    Object? a24 = freezed,
    Object? a25 = freezed,
    Object? a26 = freezed,
    Object? a27 = freezed,
    Object? a28 = freezed,
    Object? a29 = freezed,
  }) {
    return _then(_value.copyWith(
      a0: freezed == a0
          ? _value.a0
          : a0 // ignore: cast_nullable_to_non_nullable
              as int?,
      a1: freezed == a1
          ? _value.a1
          : a1 // ignore: cast_nullable_to_non_nullable
              as int?,
      a2: freezed == a2
          ? _value.a2
          : a2 // ignore: cast_nullable_to_non_nullable
              as int?,
      a3: freezed == a3
          ? _value.a3
          : a3 // ignore: cast_nullable_to_non_nullable
              as int?,
      a4: freezed == a4
          ? _value.a4
          : a4 // ignore: cast_nullable_to_non_nullable
              as int?,
      a5: freezed == a5
          ? _value.a5
          : a5 // ignore: cast_nullable_to_non_nullable
              as int?,
      a6: freezed == a6
          ? _value.a6
          : a6 // ignore: cast_nullable_to_non_nullable
              as int?,
      a7: freezed == a7
          ? _value.a7
          : a7 // ignore: cast_nullable_to_non_nullable
              as int?,
      a8: freezed == a8
          ? _value.a8
          : a8 // ignore: cast_nullable_to_non_nullable
              as int?,
      a9: freezed == a9
          ? _value.a9
          : a9 // ignore: cast_nullable_to_non_nullable
              as int?,
      a10: freezed == a10
          ? _value.a10
          : a10 // ignore: cast_nullable_to_non_nullable
              as int?,
      a11: freezed == a11
          ? _value.a11
          : a11 // ignore: cast_nullable_to_non_nullable
              as int?,
      a12: freezed == a12
          ? _value.a12
          : a12 // ignore: cast_nullable_to_non_nullable
              as int?,
      a13: freezed == a13
          ? _value.a13
          : a13 // ignore: cast_nullable_to_non_nullable
              as int?,
      a14: freezed == a14
          ? _value.a14
          : a14 // ignore: cast_nullable_to_non_nullable
              as int?,
      a15: freezed == a15
          ? _value.a15
          : a15 // ignore: cast_nullable_to_non_nullable
              as int?,
      a16: freezed == a16
          ? _value.a16
          : a16 // ignore: cast_nullable_to_non_nullable
              as int?,
      a17: freezed == a17
          ? _value.a17
          : a17 // ignore: cast_nullable_to_non_nullable
              as int?,
      a18: freezed == a18
          ? _value.a18
          : a18 // ignore: cast_nullable_to_non_nullable
              as int?,
      a19: freezed == a19
          ? _value.a19
          : a19 // ignore: cast_nullable_to_non_nullable
              as int?,
      a20: freezed == a20
          ? _value.a20
          : a20 // ignore: cast_nullable_to_non_nullable
              as int?,
      a21: freezed == a21
          ? _value.a21
          : a21 // ignore: cast_nullable_to_non_nullable
              as int?,
      a22: freezed == a22
          ? _value.a22
          : a22 // ignore: cast_nullable_to_non_nullable
              as int?,
      a23: freezed == a23
          ? _value.a23
          : a23 // ignore: cast_nullable_to_non_nullable
              as int?,
      a24: freezed == a24
          ? _value.a24
          : a24 // ignore: cast_nullable_to_non_nullable
              as int?,
      a25: freezed == a25
          ? _value.a25
          : a25 // ignore: cast_nullable_to_non_nullable
              as int?,
      a26: freezed == a26
          ? _value.a26
          : a26 // ignore: cast_nullable_to_non_nullable
              as int?,
      a27: freezed == a27
          ? _value.a27
          : a27 // ignore: cast_nullable_to_non_nullable
              as int?,
      a28: freezed == a28
          ? _value.a28
          : a28 // ignore: cast_nullable_to_non_nullable
              as int?,
      a29: freezed == a29
          ? _value.a29
          : a29 // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LargeCopyWith<$Res> implements $LargeCopyWith<$Res> {
  factory _$$_LargeCopyWith(_$_Large value, $Res Function(_$_Large) then) =
      __$$_LargeCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int? a0,
      int? a1,
      int? a2,
      int? a3,
      int? a4,
      int? a5,
      int? a6,
      int? a7,
      int? a8,
      int? a9,
      int? a10,
      int? a11,
      int? a12,
      int? a13,
      int? a14,
      int? a15,
      int? a16,
      int? a17,
      int? a18,
      int? a19,
      int? a20,
      int? a21,
      int? a22,
      int? a23,
      int? a24,
      int? a25,
      int? a26,
      int? a27,
      int? a28,
      int? a29});
}

/// @nodoc
class __$$_LargeCopyWithImpl<$Res> extends _$LargeCopyWithImpl<$Res, _$_Large>
    implements _$$_LargeCopyWith<$Res> {
  __$$_LargeCopyWithImpl(_$_Large _value, $Res Function(_$_Large) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a0 = freezed,
    Object? a1 = freezed,
    Object? a2 = freezed,
    Object? a3 = freezed,
    Object? a4 = freezed,
    Object? a5 = freezed,
    Object? a6 = freezed,
    Object? a7 = freezed,
    Object? a8 = freezed,
    Object? a9 = freezed,
    Object? a10 = freezed,
    Object? a11 = freezed,
    Object? a12 = freezed,
    Object? a13 = freezed,
    Object? a14 = freezed,
    Object? a15 = freezed,
    Object? a16 = freezed,
    Object? a17 = freezed,
    Object? a18 = freezed,
    Object? a19 = freezed,
    Object? a20 = freezed,
    Object? a21 = freezed,
    Object? a22 = freezed,
    Object? a23 = freezed,
    Object? a24 = freezed,
    Object? a25 = freezed,
    Object? a26 = freezed,
    Object? a27 = freezed,
    Object? a28 = freezed,
    Object? a29 = freezed,
  }) {
    return _then(_$_Large(
      a0: freezed == a0
          ? _value.a0
          : a0 // ignore: cast_nullable_to_non_nullable
              as int?,
      a1: freezed == a1
          ? _value.a1
          : a1 // ignore: cast_nullable_to_non_nullable
              as int?,
      a2: freezed == a2
          ? _value.a2
          : a2 // ignore: cast_nullable_to_non_nullable
              as int?,
      a3: freezed == a3
          ? _value.a3
          : a3 // ignore: cast_nullable_to_non_nullable
              as int?,
      a4: freezed == a4
          ? _value.a4
          : a4 // ignore: cast_nullable_to_non_nullable
              as int?,
      a5: freezed == a5
          ? _value.a5
          : a5 // ignore: cast_nullable_to_non_nullable
              as int?,
      a6: freezed == a6
          ? _value.a6
          : a6 // ignore: cast_nullable_to_non_nullable
              as int?,
      a7: freezed == a7
          ? _value.a7
          : a7 // ignore: cast_nullable_to_non_nullable
              as int?,
      a8: freezed == a8
          ? _value.a8
          : a8 // ignore: cast_nullable_to_non_nullable
              as int?,
      a9: freezed == a9
          ? _value.a9
          : a9 // ignore: cast_nullable_to_non_nullable
              as int?,
      a10: freezed == a10
          ? _value.a10
          : a10 // ignore: cast_nullable_to_non_nullable
              as int?,
      a11: freezed == a11
          ? _value.a11
          : a11 // ignore: cast_nullable_to_non_nullable
              as int?,
      a12: freezed == a12
          ? _value.a12
          : a12 // ignore: cast_nullable_to_non_nullable
              as int?,
      a13: freezed == a13
          ? _value.a13
          : a13 // ignore: cast_nullable_to_non_nullable
              as int?,
      a14: freezed == a14
          ? _value.a14
          : a14 // ignore: cast_nullable_to_non_nullable
              as int?,
      a15: freezed == a15
          ? _value.a15
          : a15 // ignore: cast_nullable_to_non_nullable
              as int?,
      a16: freezed == a16
          ? _value.a16
          : a16 // ignore: cast_nullable_to_non_nullable
              as int?,
      a17: freezed == a17
          ? _value.a17
          : a17 // ignore: cast_nullable_to_non_nullable
              as int?,
      a18: freezed == a18
          ? _value.a18
          : a18 // ignore: cast_nullable_to_non_nullable
              as int?,
      a19: freezed == a19
          ? _value.a19
          : a19 // ignore: cast_nullable_to_non_nullable
              as int?,
      a20: freezed == a20
          ? _value.a20
          : a20 // ignore: cast_nullable_to_non_nullable
              as int?,
      a21: freezed == a21
          ? _value.a21
          : a21 // ignore: cast_nullable_to_non_nullable
              as int?,
      a22: freezed == a22
          ? _value.a22
          : a22 // ignore: cast_nullable_to_non_nullable
              as int?,
      a23: freezed == a23
          ? _value.a23
          : a23 // ignore: cast_nullable_to_non_nullable
              as int?,
      a24: freezed == a24
          ? _value.a24
          : a24 // ignore: cast_nullable_to_non_nullable
              as int?,
      a25: freezed == a25
          ? _value.a25
          : a25 // ignore: cast_nullable_to_non_nullable
              as int?,
      a26: freezed == a26
          ? _value.a26
          : a26 // ignore: cast_nullable_to_non_nullable
              as int?,
      a27: freezed == a27
          ? _value.a27
          : a27 // ignore: cast_nullable_to_non_nullable
              as int?,
      a28: freezed == a28
          ? _value.a28
          : a28 // ignore: cast_nullable_to_non_nullable
              as int?,
      a29: freezed == a29
          ? _value.a29
          : a29 // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$_Large implements _Large {
  _$_Large(
      {this.a0 = 0,
      this.a1 = 1,
      this.a2 = 2,
      this.a3 = 3,
      this.a4 = 4,
      this.a5 = 5,
      this.a6 = 6,
      this.a7 = 7,
      this.a8 = 8,
      this.a9 = 9,
      this.a10 = 10,
      this.a11 = 11,
      this.a12 = 12,
      this.a13 = 13,
      this.a14 = 14,
      this.a15 = 15,
      this.a16 = 16,
      this.a17 = 17,
      this.a18 = 18,
      this.a19 = 19,
      this.a20 = 20,
      this.a21 = 21,
      this.a22 = 22,
      this.a23 = 23,
      this.a24 = 24,
      this.a25 = 25,
      this.a26 = 26,
      this.a27 = 27,
      this.a28 = 28,
      this.a29 = 29});

  @override
  @JsonKey()
  final int? a0;
  @override
  @JsonKey()
  final int? a1;
  @override
  @JsonKey()
  final int? a2;
  @override
  @JsonKey()
  final int? a3;
  @override
  @JsonKey()
  final int? a4;
  @override
  @JsonKey()
  final int? a5;
  @override
  @JsonKey()
  final int? a6;
  @override
  @JsonKey()
  final int? a7;
  @override
  @JsonKey()
  final int? a8;
  @override
  @JsonKey()
  final int? a9;
  @override
  @JsonKey()
  final int? a10;
  @override
  @JsonKey()
  final int? a11;
  @override
  @JsonKey()
  final int? a12;
  @override
  @JsonKey()
  final int? a13;
  @override
  @JsonKey()
  final int? a14;
  @override
  @JsonKey()
  final int? a15;
  @override
  @JsonKey()
  final int? a16;
  @override
  @JsonKey()
  final int? a17;
  @override
  @JsonKey()
  final int? a18;
  @override
  @JsonKey()
  final int? a19;
  @override
  @JsonKey()
  final int? a20;
  @override
  @JsonKey()
  final int? a21;
  @override
  @JsonKey()
  final int? a22;
  @override
  @JsonKey()
  final int? a23;
  @override
  @JsonKey()
  final int? a24;
  @override
  @JsonKey()
  final int? a25;
  @override
  @JsonKey()
  final int? a26;
  @override
  @JsonKey()
  final int? a27;
  @override
  @JsonKey()
  final int? a28;
  @override
  @JsonKey()
  final int? a29;

  @override
  String toString() {
    return 'Large(a0: $a0, a1: $a1, a2: $a2, a3: $a3, a4: $a4, a5: $a5, a6: $a6, a7: $a7, a8: $a8, a9: $a9, a10: $a10, a11: $a11, a12: $a12, a13: $a13, a14: $a14, a15: $a15, a16: $a16, a17: $a17, a18: $a18, a19: $a19, a20: $a20, a21: $a21, a22: $a22, a23: $a23, a24: $a24, a25: $a25, a26: $a26, a27: $a27, a28: $a28, a29: $a29)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Large &&
            (identical(other.a0, a0) || other.a0 == a0) &&
            (identical(other.a1, a1) || other.a1 == a1) &&
            (identical(other.a2, a2) || other.a2 == a2) &&
            (identical(other.a3, a3) || other.a3 == a3) &&
            (identical(other.a4, a4) || other.a4 == a4) &&
            (identical(other.a5, a5) || other.a5 == a5) &&
            (identical(other.a6, a6) || other.a6 == a6) &&
            (identical(other.a7, a7) || other.a7 == a7) &&
            (identical(other.a8, a8) || other.a8 == a8) &&
            (identical(other.a9, a9) || other.a9 == a9) &&
            (identical(other.a10, a10) || other.a10 == a10) &&
            (identical(other.a11, a11) || other.a11 == a11) &&
            (identical(other.a12, a12) || other.a12 == a12) &&
            (identical(other.a13, a13) || other.a13 == a13) &&
            (identical(other.a14, a14) || other.a14 == a14) &&
            (identical(other.a15, a15) || other.a15 == a15) &&
            (identical(other.a16, a16) || other.a16 == a16) &&
            (identical(other.a17, a17) || other.a17 == a17) &&
            (identical(other.a18, a18) || other.a18 == a18) &&
            (identical(other.a19, a19) || other.a19 == a19) &&
            (identical(other.a20, a20) || other.a20 == a20) &&
            (identical(other.a21, a21) || other.a21 == a21) &&
            (identical(other.a22, a22) || other.a22 == a22) &&
            (identical(other.a23, a23) || other.a23 == a23) &&
            (identical(other.a24, a24) || other.a24 == a24) &&
            (identical(other.a25, a25) || other.a25 == a25) &&
            (identical(other.a26, a26) || other.a26 == a26) &&
            (identical(other.a27, a27) || other.a27 == a27) &&
            (identical(other.a28, a28) || other.a28 == a28) &&
            (identical(other.a29, a29) || other.a29 == a29));
  }

  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        a0,
        a1,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14,
        a15,
        a16,
        a17,
        a18,
        a19,
        a20,
        a21,
        a22,
        a23,
        a24,
        a25,
        a26,
        a27,
        a28,
        a29
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LargeCopyWith<_$_Large> get copyWith =>
      __$$_LargeCopyWithImpl<_$_Large>(this, _$identity);
}

abstract class _Large implements Large {
  factory _Large(
      {final int? a0,
      final int? a1,
      final int? a2,
      final int? a3,
      final int? a4,
      final int? a5,
      final int? a6,
      final int? a7,
      final int? a8,
      final int? a9,
      final int? a10,
      final int? a11,
      final int? a12,
      final int? a13,
      final int? a14,
      final int? a15,
      final int? a16,
      final int? a17,
      final int? a18,
      final int? a19,
      final int? a20,
      final int? a21,
      final int? a22,
      final int? a23,
      final int? a24,
      final int? a25,
      final int? a26,
      final int? a27,
      final int? a28,
      final int? a29}) = _$_Large;

  @override
  int? get a0;
  @override
  int? get a1;
  @override
  int? get a2;
  @override
  int? get a3;
  @override
  int? get a4;
  @override
  int? get a5;
  @override
  int? get a6;
  @override
  int? get a7;
  @override
  int? get a8;
  @override
  int? get a9;
  @override
  int? get a10;
  @override
  int? get a11;
  @override
  int? get a12;
  @override
  int? get a13;
  @override
  int? get a14;
  @override
  int? get a15;
  @override
  int? get a16;
  @override
  int? get a17;
  @override
  int? get a18;
  @override
  int? get a19;
  @override
  int? get a20;
  @override
  int? get a21;
  @override
  int? get a22;
  @override
  int? get a23;
  @override
  int? get a24;
  @override
  int? get a25;
  @override
  int? get a26;
  @override
  int? get a27;
  @override
  int? get a28;
  @override
  int? get a29;
  @override
  @JsonKey(ignore: true)
  _$$_LargeCopyWith<_$_Large> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Regression131 {
  String get versionName => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Regression131CopyWith<Regression131> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Regression131CopyWith<$Res> {
  factory $Regression131CopyWith(
          Regression131 value, $Res Function(Regression131) then) =
      _$Regression131CopyWithImpl<$Res, Regression131>;
  @useResult
  $Res call({String versionName});
}

/// @nodoc
class _$Regression131CopyWithImpl<$Res, $Val extends Regression131>
    implements $Regression131CopyWith<$Res> {
  _$Regression131CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? versionName = null,
  }) {
    return _then(_value.copyWith(
      versionName: null == versionName
          ? _value.versionName
          : versionName // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_Regression131CopyWith<$Res>
    implements $Regression131CopyWith<$Res> {
  factory _$$_Regression131CopyWith(
          _$_Regression131 value, $Res Function(_$_Regression131) then) =
      __$$_Regression131CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String versionName});
}

/// @nodoc
class __$$_Regression131CopyWithImpl<$Res>
    extends _$Regression131CopyWithImpl<$Res, _$_Regression131>
    implements _$$_Regression131CopyWith<$Res> {
  __$$_Regression131CopyWithImpl(
      _$_Regression131 _value, $Res Function(_$_Regression131) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? versionName = null,
  }) {
    return _then(_$_Regression131(
      null == versionName
          ? _value.versionName
          : versionName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Regression131 implements _Regression131 {
  _$_Regression131(this.versionName);

  @override
  final String versionName;

  @override
  String toString() {
    return 'Regression131(versionName: $versionName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Regression131 &&
            (identical(other.versionName, versionName) ||
                other.versionName == versionName));
  }

  @override
  int get hashCode => Object.hash(runtimeType, versionName);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_Regression131CopyWith<_$_Regression131> get copyWith =>
      __$$_Regression131CopyWithImpl<_$_Regression131>(this, _$identity);
}

abstract class _Regression131 implements Regression131 {
  factory _Regression131(final String versionName) = _$_Regression131;

  @override
  String get versionName;
  @override
  @JsonKey(ignore: true)
  _$$_Regression131CopyWith<_$_Regression131> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$UnimplementedGetter {
  int get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnimplementedGetterCopyWith<UnimplementedGetter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnimplementedGetterCopyWith<$Res> {
  factory $UnimplementedGetterCopyWith(
          UnimplementedGetter value, $Res Function(UnimplementedGetter) then) =
      _$UnimplementedGetterCopyWithImpl<$Res, UnimplementedGetter>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class _$UnimplementedGetterCopyWithImpl<$Res, $Val extends UnimplementedGetter>
    implements $UnimplementedGetterCopyWith<$Res> {
  _$UnimplementedGetterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_UnimplementedGetterCopyWith<$Res>
    implements $UnimplementedGetterCopyWith<$Res> {
  factory _$$_UnimplementedGetterCopyWith(_$_UnimplementedGetter value,
          $Res Function(_$_UnimplementedGetter) then) =
      __$$_UnimplementedGetterCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$_UnimplementedGetterCopyWithImpl<$Res>
    extends _$UnimplementedGetterCopyWithImpl<$Res, _$_UnimplementedGetter>
    implements _$$_UnimplementedGetterCopyWith<$Res> {
  __$$_UnimplementedGetterCopyWithImpl(_$_UnimplementedGetter _value,
      $Res Function(_$_UnimplementedGetter) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_UnimplementedGetter(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_UnimplementedGetter implements _UnimplementedGetter {
  _$_UnimplementedGetter(this.value);

  @override
  final int value;

  @override
  String toString() {
    return 'UnimplementedGetter(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_UnimplementedGetter &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_UnimplementedGetterCopyWith<_$_UnimplementedGetter> get copyWith =>
      __$$_UnimplementedGetterCopyWithImpl<_$_UnimplementedGetter>(
          this, _$identity);
}

abstract class _UnimplementedGetter implements UnimplementedGetter {
  factory _UnimplementedGetter(final int value) = _$_UnimplementedGetter;

  @override
  int get value;
  @override
  @JsonKey(ignore: true)
  _$$_UnimplementedGetterCopyWith<_$_UnimplementedGetter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Assertion {
  int get a => throw _privateConstructorUsedError;
  int get b => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AssertionCopyWith<Assertion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssertionCopyWith<$Res> {
  factory $AssertionCopyWith(Assertion value, $Res Function(Assertion) then) =
      _$AssertionCopyWithImpl<$Res, Assertion>;
  @useResult
  $Res call({int a, int b});
}

/// @nodoc
class _$AssertionCopyWithImpl<$Res, $Val extends Assertion>
    implements $AssertionCopyWith<$Res> {
  _$AssertionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = null,
  }) {
    return _then(_value.copyWith(
      a: null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
      b: null == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AssertionCopyWith<$Res> implements $AssertionCopyWith<$Res> {
  factory _$$_AssertionCopyWith(
          _$_Assertion value, $Res Function(_$_Assertion) then) =
      __$$_AssertionCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int a, int b});
}

/// @nodoc
class __$$_AssertionCopyWithImpl<$Res>
    extends _$AssertionCopyWithImpl<$Res, _$_Assertion>
    implements _$$_AssertionCopyWith<$Res> {
  __$$_AssertionCopyWithImpl(
      _$_Assertion _value, $Res Function(_$_Assertion) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = null,
  }) {
    return _then(_$_Assertion(
      null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
      null == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Assertion implements _Assertion {
  _$_Assertion(this.a, this.b)
      : assert(a > 0),
        assert(b > a);

  @override
  final int a;
  @override
  final int b;

  @override
  String toString() {
    return 'Assertion(a: $a, b: $b)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Assertion &&
            (identical(other.a, a) || other.a == a) &&
            (identical(other.b, b) || other.b == b));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a, b);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AssertionCopyWith<_$_Assertion> get copyWith =>
      __$$_AssertionCopyWithImpl<_$_Assertion>(this, _$identity);
}

abstract class _Assertion implements Assertion {
  factory _Assertion(final int a, final int b) = _$_Assertion;

  @override
  int get a;
  @override
  int get b;
  @override
  @JsonKey(ignore: true)
  _$$_AssertionCopyWith<_$_Assertion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Doc326 {
  int? get named => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Doc326CopyWith<Doc326> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Doc326CopyWith<$Res> {
  factory $Doc326CopyWith(Doc326 value, $Res Function(Doc326) then) =
      _$Doc326CopyWithImpl<$Res, Doc326>;
  @useResult
  $Res call({int? named});
}

/// @nodoc
class _$Doc326CopyWithImpl<$Res, $Val extends Doc326>
    implements $Doc326CopyWith<$Res> {
  _$Doc326CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? named = freezed,
  }) {
    return _then(_value.copyWith(
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_Doc326CopyWith<$Res> implements $Doc326CopyWith<$Res> {
  factory _$$_Doc326CopyWith(_$_Doc326 value, $Res Function(_$_Doc326) then) =
      __$$_Doc326CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? named});
}

/// @nodoc
class __$$_Doc326CopyWithImpl<$Res>
    extends _$Doc326CopyWithImpl<$Res, _$_Doc326>
    implements _$$_Doc326CopyWith<$Res> {
  __$$_Doc326CopyWithImpl(_$_Doc326 _value, $Res Function(_$_Doc326) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? named = freezed,
  }) {
    return _then(_$_Doc326(
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$_Doc326 implements _Doc326 {
  _$_Doc326({this.named});

  @override
  final int? named;

  @override
  String toString() {
    return 'Doc326(named: $named)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Doc326 &&
            (identical(other.named, named) || other.named == named));
  }

  @override
  int get hashCode => Object.hash(runtimeType, named);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_Doc326CopyWith<_$_Doc326> get copyWith =>
      __$$_Doc326CopyWithImpl<_$_Doc326>(this, _$identity);
}

abstract class _Doc326 implements Doc326 {
  factory _Doc326({final int? named}) = _$_Doc326;

  @override
  int? get named;
  @override
  @JsonKey(ignore: true)
  _$$_Doc326CopyWith<_$_Doc326> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Doc317 {
  /// )
  int? get named => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Doc317CopyWith<Doc317> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Doc317CopyWith<$Res> {
  factory $Doc317CopyWith(Doc317 value, $Res Function(Doc317) then) =
      _$Doc317CopyWithImpl<$Res, Doc317>;
  @useResult
  $Res call({int? named});
}

/// @nodoc
class _$Doc317CopyWithImpl<$Res, $Val extends Doc317>
    implements $Doc317CopyWith<$Res> {
  _$Doc317CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? named = freezed,
  }) {
    return _then(_value.copyWith(
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_Doc317CopyWith<$Res> implements $Doc317CopyWith<$Res> {
  factory _$$_Doc317CopyWith(_$_Doc317 value, $Res Function(_$_Doc317) then) =
      __$$_Doc317CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? named});
}

/// @nodoc
class __$$_Doc317CopyWithImpl<$Res>
    extends _$Doc317CopyWithImpl<$Res, _$_Doc317>
    implements _$$_Doc317CopyWith<$Res> {
  __$$_Doc317CopyWithImpl(_$_Doc317 _value, $Res Function(_$_Doc317) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? named = freezed,
  }) {
    return _then(_$_Doc317(
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$_Doc317 implements _Doc317 {
  _$_Doc317({this.named});

  /// )
  @override
  final int? named;

  @override
  String toString() {
    return 'Doc317(named: $named)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Doc317 &&
            (identical(other.named, named) || other.named == named));
  }

  @override
  int get hashCode => Object.hash(runtimeType, named);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_Doc317CopyWith<_$_Doc317> get copyWith =>
      __$$_Doc317CopyWithImpl<_$_Doc317>(this, _$identity);
}

abstract class _Doc317 implements Doc317 {
  factory _Doc317({final int? named}) = _$_Doc317;

  @override

  /// )
  int? get named;
  @override
  @JsonKey(ignore: true)
  _$$_Doc317CopyWith<_$_Doc317> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Doc {
  /// Multi
  /// line
  /// positional
  int get positional => throw _privateConstructorUsedError;

  /// Single line named
  int? get named => throw _privateConstructorUsedError; // Simple
  int? get simple => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DocCopyWith<Doc> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DocCopyWith<$Res> {
  factory $DocCopyWith(Doc value, $Res Function(Doc) then) =
      _$DocCopyWithImpl<$Res, Doc>;
  @useResult
  $Res call({int positional, int? named, int? simple});
}

/// @nodoc
class _$DocCopyWithImpl<$Res, $Val extends Doc> implements $DocCopyWith<$Res> {
  _$DocCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? positional = null,
    Object? named = freezed,
    Object? simple = freezed,
  }) {
    return _then(_value.copyWith(
      positional: null == positional
          ? _value.positional
          : positional // ignore: cast_nullable_to_non_nullable
              as int,
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
      simple: freezed == simple
          ? _value.simple
          : simple // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DocCopyWith<$Res> implements $DocCopyWith<$Res> {
  factory _$$_DocCopyWith(_$_Doc value, $Res Function(_$_Doc) then) =
      __$$_DocCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int positional, int? named, int? simple});
}

/// @nodoc
class __$$_DocCopyWithImpl<$Res> extends _$DocCopyWithImpl<$Res, _$_Doc>
    implements _$$_DocCopyWith<$Res> {
  __$$_DocCopyWithImpl(_$_Doc _value, $Res Function(_$_Doc) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? positional = null,
    Object? named = freezed,
    Object? simple = freezed,
  }) {
    return _then(_$_Doc(
      null == positional
          ? _value.positional
          : positional // ignore: cast_nullable_to_non_nullable
              as int,
      named: freezed == named
          ? _value.named
          : named // ignore: cast_nullable_to_non_nullable
              as int?,
      simple: freezed == simple
          ? _value.simple
          : simple // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$_Doc implements _Doc {
  _$_Doc(this.positional, {this.named, this.simple});

  /// Multi
  /// line
  /// positional
  @override
  final int positional;

  /// Single line named
  @override
  final int? named;
// Simple
  @override
  final int? simple;

  @override
  String toString() {
    return 'Doc(positional: $positional, named: $named, simple: $simple)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Doc &&
            (identical(other.positional, positional) ||
                other.positional == positional) &&
            (identical(other.named, named) || other.named == named) &&
            (identical(other.simple, simple) || other.simple == simple));
  }

  @override
  int get hashCode => Object.hash(runtimeType, positional, named, simple);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DocCopyWith<_$_Doc> get copyWith =>
      __$$_DocCopyWithImpl<_$_Doc>(this, _$identity);
}

abstract class _Doc implements Doc {
  factory _Doc(final int positional, {final int? named, final int? simple}) =
      _$_Doc;

  @override

  /// Multi
  /// line
  /// positional
  int get positional;
  @override

  /// Single line named
  int? get named;
  @override // Simple
  int? get simple;
  @override
  @JsonKey(ignore: true)
  _$$_DocCopyWith<_$_Doc> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Product {
  String? get name => throw _privateConstructorUsedError;
  Product? get parent => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ProductCopyWith<Product> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProductCopyWith<$Res> {
  factory $ProductCopyWith(Product value, $Res Function(Product) then) =
      _$ProductCopyWithImpl<$Res, Product>;
  @useResult
  $Res call({String? name, Product? parent});

  $ProductCopyWith<$Res>? get parent;
}

/// @nodoc
class _$ProductCopyWithImpl<$Res, $Val extends Product>
    implements $ProductCopyWith<$Res> {
  _$ProductCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? parent = freezed,
  }) {
    return _then(_value.copyWith(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Product?,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ProductCopyWith<$Res>? get parent {
    if (_value.parent == null) {
      return null;
    }

    return $ProductCopyWith<$Res>(_value.parent!, (value) {
      return _then(_value.copyWith(parent: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$_ProductDataClassCopyWith<$Res>
    implements $ProductCopyWith<$Res> {
  factory _$$_ProductDataClassCopyWith(
          _$_ProductDataClass value, $Res Function(_$_ProductDataClass) then) =
      __$$_ProductDataClassCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? name, Product? parent});

  @override
  $ProductCopyWith<$Res>? get parent;
}

/// @nodoc
class __$$_ProductDataClassCopyWithImpl<$Res>
    extends _$ProductCopyWithImpl<$Res, _$_ProductDataClass>
    implements _$$_ProductDataClassCopyWith<$Res> {
  __$$_ProductDataClassCopyWithImpl(
      _$_ProductDataClass _value, $Res Function(_$_ProductDataClass) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = freezed,
    Object? parent = freezed,
  }) {
    return _then(_$_ProductDataClass(
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      parent: freezed == parent
          ? _value.parent
          : parent // ignore: cast_nullable_to_non_nullable
              as Product?,
    ));
  }
}

/// @nodoc

class _$_ProductDataClass implements _ProductDataClass {
  const _$_ProductDataClass({this.name, this.parent});

  @override
  final String? name;
  @override
  final Product? parent;

  @override
  String toString() {
    return 'Product(name: $name, parent: $parent)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ProductDataClass &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.parent, parent) || other.parent == parent));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name, parent);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ProductDataClassCopyWith<_$_ProductDataClass> get copyWith =>
      __$$_ProductDataClassCopyWithImpl<_$_ProductDataClass>(this, _$identity);
}

abstract class _ProductDataClass implements Product {
  const factory _ProductDataClass({final String? name, final Product? parent}) =
      _$_ProductDataClass;

  @override
  String? get name;
  @override
  Product? get parent;
  @override
  @JsonKey(ignore: true)
  _$$_ProductDataClassCopyWith<_$_ProductDataClass> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Test {
  Completer<dynamic> get completer => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Completer<dynamic> completer) something,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Completer<dynamic> completer)? something,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Completer<dynamic> completer)? something,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestSomething value) something,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestSomething value)? something,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestSomething value)? something,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TestCopyWith<Test> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TestCopyWith<$Res> {
  factory $TestCopyWith(Test value, $Res Function(Test) then) =
      _$TestCopyWithImpl<$Res, Test>;
  @useResult
  $Res call({Completer<dynamic> completer});
}

/// @nodoc
class _$TestCopyWithImpl<$Res, $Val extends Test>
    implements $TestCopyWith<$Res> {
  _$TestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completer = null,
  }) {
    return _then(_value.copyWith(
      completer: null == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TestSomethingCopyWith<$Res> implements $TestCopyWith<$Res> {
  factory _$$TestSomethingCopyWith(
          _$TestSomething value, $Res Function(_$TestSomething) then) =
      __$$TestSomethingCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Completer<dynamic> completer});
}

/// @nodoc
class __$$TestSomethingCopyWithImpl<$Res>
    extends _$TestCopyWithImpl<$Res, _$TestSomething>
    implements _$$TestSomethingCopyWith<$Res> {
  __$$TestSomethingCopyWithImpl(
      _$TestSomething _value, $Res Function(_$TestSomething) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? completer = null,
  }) {
    return _then(_$TestSomething(
      null == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<dynamic>,
    ));
  }
}

/// @nodoc

class _$TestSomething implements TestSomething {
  const _$TestSomething(this.completer);

  @override
  final Completer<dynamic> completer;

  @override
  String toString() {
    return 'Test.something(completer: $completer)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TestSomething &&
            (identical(other.completer, completer) ||
                other.completer == completer));
  }

  @override
  int get hashCode => Object.hash(runtimeType, completer);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$TestSomethingCopyWith<_$TestSomething> get copyWith =>
      __$$TestSomethingCopyWithImpl<_$TestSomething>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Completer<dynamic> completer) something,
  }) {
    return something(completer);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Completer<dynamic> completer)? something,
  }) {
    return something?.call(completer);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Completer<dynamic> completer)? something,
    required TResult orElse(),
  }) {
    if (something != null) {
      return something(completer);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(TestSomething value) something,
  }) {
    return something(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(TestSomething value)? something,
  }) {
    return something?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(TestSomething value)? something,
    required TResult orElse(),
  }) {
    if (something != null) {
      return something(this);
    }
    return orElse();
  }
}

abstract class TestSomething implements Test {
  const factory TestSomething(final Completer<dynamic> completer) =
      _$TestSomething;

  @override
  Completer<dynamic> get completer;
  @override
  @JsonKey(ignore: true)
  _$$TestSomethingCopyWith<_$TestSomething> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Private {
  Iterable<String> get items => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PrivateCopyWith<Private> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PrivateCopyWith<$Res> {
  factory $PrivateCopyWith(Private value, $Res Function(Private) then) =
      _$PrivateCopyWithImpl<$Res, Private>;
  @useResult
  $Res call({Iterable<String> items});
}

/// @nodoc
class _$PrivateCopyWithImpl<$Res, $Val extends Private>
    implements $PrivateCopyWith<$Res> {
  _$PrivateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
  }) {
    return _then(_value.copyWith(
      items: null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as Iterable<String>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_PrivateCopyWith<$Res> implements $PrivateCopyWith<$Res> {
  factory _$$_PrivateCopyWith(
          _$_Private value, $Res Function(_$_Private) then) =
      __$$_PrivateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Iterable<String> items});
}

/// @nodoc
class __$$_PrivateCopyWithImpl<$Res>
    extends _$PrivateCopyWithImpl<$Res, _$_Private>
    implements _$$_PrivateCopyWith<$Res> {
  __$$_PrivateCopyWithImpl(_$_Private _value, $Res Function(_$_Private) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? items = null,
  }) {
    return _then(_$_Private(
      null == items
          ? _value.items
          : items // ignore: cast_nullable_to_non_nullable
              as Iterable<String>,
    ));
  }
}

/// @nodoc

class _$_Private implements _Private {
  const _$_Private(this.items);

  @override
  final Iterable<String> items;

  @override
  String toString() {
    return 'Private._internal(items: $items)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Private &&
            const DeepCollectionEquality().equals(other.items, items));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(items));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_PrivateCopyWith<_$_Private> get copyWith =>
      __$$_PrivateCopyWithImpl<_$_Private>(this, _$identity);
}

abstract class _Private implements Private {
  const factory _Private(final Iterable<String> items) = _$_Private;

  @override
  Iterable<String> get items;
  @override
  @JsonKey(ignore: true)
  _$$_PrivateCopyWith<_$_Private> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MyClass {
  String? get a => throw _privateConstructorUsedError;
  int? get b => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MyClassCopyWith<MyClass> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyClassCopyWith<$Res> {
  factory $MyClassCopyWith(MyClass value, $Res Function(MyClass) then) =
      _$MyClassCopyWithImpl<$Res, MyClass>;
  @useResult
  $Res call({String? a, int? b});
}

/// @nodoc
class _$MyClassCopyWithImpl<$Res, $Val extends MyClass>
    implements $MyClassCopyWith<$Res> {
  _$MyClassCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String?,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WhateverIWantCopyWith<$Res>
    implements $MyClassCopyWith<$Res> {
  factory _$$WhateverIWantCopyWith(
          _$WhateverIWant value, $Res Function(_$WhateverIWant) then) =
      __$$WhateverIWantCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? a, int? b});
}

/// @nodoc
class __$$WhateverIWantCopyWithImpl<$Res>
    extends _$MyClassCopyWithImpl<$Res, _$WhateverIWant>
    implements _$$WhateverIWantCopyWith<$Res> {
  __$$WhateverIWantCopyWithImpl(
      _$WhateverIWant _value, $Res Function(_$WhateverIWant) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
    Object? b = freezed,
  }) {
    return _then(_$WhateverIWant(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String?,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$WhateverIWant implements WhateverIWant {
  const _$WhateverIWant({this.a, this.b});

  @override
  final String? a;
  @override
  final int? b;

  @override
  String toString() {
    return 'MyClass(a: $a, b: $b)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WhateverIWant &&
            (identical(other.a, a) || other.a == a) &&
            (identical(other.b, b) || other.b == b));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a, b);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WhateverIWantCopyWith<_$WhateverIWant> get copyWith =>
      __$$WhateverIWantCopyWithImpl<_$WhateverIWant>(this, _$identity);
}

abstract class WhateverIWant implements MyClass {
  const factory WhateverIWant({final String? a, final int? b}) =
      _$WhateverIWant;

  @override
  String? get a;
  @override
  int? get b;
  @override
  @JsonKey(ignore: true)
  _$$WhateverIWantCopyWith<_$WhateverIWant> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MixedParam {
  String get a => throw _privateConstructorUsedError;
  int? get b => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MixedParamCopyWith<MixedParam> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MixedParamCopyWith<$Res> {
  factory $MixedParamCopyWith(
          MixedParam value, $Res Function(MixedParam) then) =
      _$MixedParamCopyWithImpl<$Res, MixedParam>;
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class _$MixedParamCopyWithImpl<$Res, $Val extends MixedParam>
    implements $MixedParamCopyWith<$Res> {
  _$MixedParamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_value.copyWith(
      a: null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WhateverMixedParamCopyWith<$Res>
    implements $MixedParamCopyWith<$Res> {
  factory _$$WhateverMixedParamCopyWith(_$WhateverMixedParam value,
          $Res Function(_$WhateverMixedParam) then) =
      __$$WhateverMixedParamCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class __$$WhateverMixedParamCopyWithImpl<$Res>
    extends _$MixedParamCopyWithImpl<$Res, _$WhateverMixedParam>
    implements _$$WhateverMixedParamCopyWith<$Res> {
  __$$WhateverMixedParamCopyWithImpl(
      _$WhateverMixedParam _value, $Res Function(_$WhateverMixedParam) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_$WhateverMixedParam(
      null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$WhateverMixedParam implements WhateverMixedParam {
  const _$WhateverMixedParam(this.a, {this.b});

  @override
  final String a;
  @override
  final int? b;

  @override
  String toString() {
    return 'MixedParam(a: $a, b: $b)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WhateverMixedParam &&
            (identical(other.a, a) || other.a == a) &&
            (identical(other.b, b) || other.b == b));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a, b);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WhateverMixedParamCopyWith<_$WhateverMixedParam> get copyWith =>
      __$$WhateverMixedParamCopyWithImpl<_$WhateverMixedParam>(
          this, _$identity);
}

abstract class WhateverMixedParam implements MixedParam {
  const factory WhateverMixedParam(final String a, {final int? b}) =
      _$WhateverMixedParam;

  @override
  String get a;
  @override
  int? get b;
  @override
  @JsonKey(ignore: true)
  _$$WhateverMixedParamCopyWith<_$WhateverMixedParam> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PositionalMixedParam {
  String get a => throw _privateConstructorUsedError;
  int? get b => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PositionalMixedParamCopyWith<PositionalMixedParam> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PositionalMixedParamCopyWith<$Res> {
  factory $PositionalMixedParamCopyWith(PositionalMixedParam value,
          $Res Function(PositionalMixedParam) then) =
      _$PositionalMixedParamCopyWithImpl<$Res, PositionalMixedParam>;
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class _$PositionalMixedParamCopyWithImpl<$Res,
        $Val extends PositionalMixedParam>
    implements $PositionalMixedParamCopyWith<$Res> {
  _$PositionalMixedParamCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_value.copyWith(
      a: null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WhateverPositionalMixedParamCopyWith<$Res>
    implements $PositionalMixedParamCopyWith<$Res> {
  factory _$$WhateverPositionalMixedParamCopyWith(
          _$WhateverPositionalMixedParam value,
          $Res Function(_$WhateverPositionalMixedParam) then) =
      __$$WhateverPositionalMixedParamCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class __$$WhateverPositionalMixedParamCopyWithImpl<$Res>
    extends _$PositionalMixedParamCopyWithImpl<$Res,
        _$WhateverPositionalMixedParam>
    implements _$$WhateverPositionalMixedParamCopyWith<$Res> {
  __$$WhateverPositionalMixedParamCopyWithImpl(
      _$WhateverPositionalMixedParam _value,
      $Res Function(_$WhateverPositionalMixedParam) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_$WhateverPositionalMixedParam(
      null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$WhateverPositionalMixedParam implements WhateverPositionalMixedParam {
  const _$WhateverPositionalMixedParam(this.a, [this.b]);

  @override
  final String a;
  @override
  final int? b;

  @override
  String toString() {
    return 'PositionalMixedParam(a: $a, b: $b)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WhateverPositionalMixedParam &&
            (identical(other.a, a) || other.a == a) &&
            (identical(other.b, b) || other.b == b));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a, b);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WhateverPositionalMixedParamCopyWith<_$WhateverPositionalMixedParam>
      get copyWith => __$$WhateverPositionalMixedParamCopyWithImpl<
          _$WhateverPositionalMixedParam>(this, _$identity);
}

abstract class WhateverPositionalMixedParam implements PositionalMixedParam {
  const factory WhateverPositionalMixedParam(final String a, [final int? b]) =
      _$WhateverPositionalMixedParam;

  @override
  String get a;
  @override
  int? get b;
  @override
  @JsonKey(ignore: true)
  _$$WhateverPositionalMixedParamCopyWith<_$WhateverPositionalMixedParam>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Required {
  String? get a => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RequiredCopyWith<Required> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RequiredCopyWith<$Res> {
  factory $RequiredCopyWith(Required value, $Res Function(Required) then) =
      _$RequiredCopyWithImpl<$Res, Required>;
  @useResult
  $Res call({String? a});
}

/// @nodoc
class _$RequiredCopyWithImpl<$Res, $Val extends Required>
    implements $RequiredCopyWith<$Res> {
  _$RequiredCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
  }) {
    return _then(_value.copyWith(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WhateverRequiredCopyWith<$Res>
    implements $RequiredCopyWith<$Res> {
  factory _$$WhateverRequiredCopyWith(
          _$WhateverRequired value, $Res Function(_$WhateverRequired) then) =
      __$$WhateverRequiredCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? a});
}

/// @nodoc
class __$$WhateverRequiredCopyWithImpl<$Res>
    extends _$RequiredCopyWithImpl<$Res, _$WhateverRequired>
    implements _$$WhateverRequiredCopyWith<$Res> {
  __$$WhateverRequiredCopyWithImpl(
      _$WhateverRequired _value, $Res Function(_$WhateverRequired) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = freezed,
  }) {
    return _then(_$WhateverRequired(
      a: freezed == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$WhateverRequired implements WhateverRequired {
  const _$WhateverRequired({required this.a});

  @override
  final String? a;

  @override
  String toString() {
    return 'Required(a: $a)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WhateverRequired &&
            (identical(other.a, a) || other.a == a));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WhateverRequiredCopyWith<_$WhateverRequired> get copyWith =>
      __$$WhateverRequiredCopyWithImpl<_$WhateverRequired>(this, _$identity);
}

abstract class WhateverRequired implements Required {
  const factory WhateverRequired({required final String? a}) =
      _$WhateverRequired;

  @override
  String? get a;
  @override
  @JsonKey(ignore: true)
  _$$WhateverRequiredCopyWith<_$WhateverRequired> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Empty {}

/// @nodoc
abstract class $EmptyCopyWith<$Res> {
  factory $EmptyCopyWith(Empty value, $Res Function(Empty) then) =
      _$EmptyCopyWithImpl<$Res, Empty>;
}

/// @nodoc
class _$EmptyCopyWithImpl<$Res, $Val extends Empty>
    implements $EmptyCopyWith<$Res> {
  _$EmptyCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WhateverEmptyCopyWith<$Res> {
  factory _$$WhateverEmptyCopyWith(
          _$WhateverEmpty value, $Res Function(_$WhateverEmpty) then) =
      __$$WhateverEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WhateverEmptyCopyWithImpl<$Res>
    extends _$EmptyCopyWithImpl<$Res, _$WhateverEmpty>
    implements _$$WhateverEmptyCopyWith<$Res> {
  __$$WhateverEmptyCopyWithImpl(
      _$WhateverEmpty _value, $Res Function(_$WhateverEmpty) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WhateverEmpty implements WhateverEmpty {
  const _$WhateverEmpty();

  @override
  String toString() {
    return 'Empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WhateverEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class WhateverEmpty implements Empty {
  const factory WhateverEmpty() = _$WhateverEmpty;
}

/// @nodoc
mixin _$Empty2 {}

/// @nodoc
abstract class $Empty2CopyWith<$Res> {
  factory $Empty2CopyWith(Empty2 value, $Res Function(Empty2) then) =
      _$Empty2CopyWithImpl<$Res, Empty2>;
}

/// @nodoc
class _$Empty2CopyWithImpl<$Res, $Val extends Empty2>
    implements $Empty2CopyWith<$Res> {
  _$Empty2CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$WhateverEmpty2CopyWith<$Res> {
  factory _$$WhateverEmpty2CopyWith(
          _$WhateverEmpty2 value, $Res Function(_$WhateverEmpty2) then) =
      __$$WhateverEmpty2CopyWithImpl<$Res>;
}

/// @nodoc
class __$$WhateverEmpty2CopyWithImpl<$Res>
    extends _$Empty2CopyWithImpl<$Res, _$WhateverEmpty2>
    implements _$$WhateverEmpty2CopyWith<$Res> {
  __$$WhateverEmpty2CopyWithImpl(
      _$WhateverEmpty2 _value, $Res Function(_$WhateverEmpty2) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WhateverEmpty2 implements WhateverEmpty2 {
  const _$WhateverEmpty2();

  @override
  String toString() {
    return 'Empty2()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WhateverEmpty2);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class WhateverEmpty2 implements Empty2 {
  const factory WhateverEmpty2() = _$WhateverEmpty2;
}

/// @nodoc
mixin _$SingleNamedCtor {
  int get a => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int a) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int a)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int a)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WhateverSingleNamedCtor value) named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WhateverSingleNamedCtor value)? named,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WhateverSingleNamedCtor value)? named,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SingleNamedCtorCopyWith<SingleNamedCtor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SingleNamedCtorCopyWith<$Res> {
  factory $SingleNamedCtorCopyWith(
          SingleNamedCtor value, $Res Function(SingleNamedCtor) then) =
      _$SingleNamedCtorCopyWithImpl<$Res, SingleNamedCtor>;
  @useResult
  $Res call({int a});
}

/// @nodoc
class _$SingleNamedCtorCopyWithImpl<$Res, $Val extends SingleNamedCtor>
    implements $SingleNamedCtorCopyWith<$Res> {
  _$SingleNamedCtorCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
  }) {
    return _then(_value.copyWith(
      a: null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WhateverSingleNamedCtorCopyWith<$Res>
    implements $SingleNamedCtorCopyWith<$Res> {
  factory _$$WhateverSingleNamedCtorCopyWith(_$WhateverSingleNamedCtor value,
          $Res Function(_$WhateverSingleNamedCtor) then) =
      __$$WhateverSingleNamedCtorCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int a});
}

/// @nodoc
class __$$WhateverSingleNamedCtorCopyWithImpl<$Res>
    extends _$SingleNamedCtorCopyWithImpl<$Res, _$WhateverSingleNamedCtor>
    implements _$$WhateverSingleNamedCtorCopyWith<$Res> {
  __$$WhateverSingleNamedCtorCopyWithImpl(_$WhateverSingleNamedCtor _value,
      $Res Function(_$WhateverSingleNamedCtor) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
  }) {
    return _then(_$WhateverSingleNamedCtor(
      null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WhateverSingleNamedCtor implements WhateverSingleNamedCtor {
  const _$WhateverSingleNamedCtor(this.a);

  @override
  final int a;

  @override
  String toString() {
    return 'SingleNamedCtor.named(a: $a)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WhateverSingleNamedCtor &&
            (identical(other.a, a) || other.a == a));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WhateverSingleNamedCtorCopyWith<_$WhateverSingleNamedCtor> get copyWith =>
      __$$WhateverSingleNamedCtorCopyWithImpl<_$WhateverSingleNamedCtor>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int a) named,
  }) {
    return named(a);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int a)? named,
  }) {
    return named?.call(a);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int a)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(a);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WhateverSingleNamedCtor value) named,
  }) {
    return named(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WhateverSingleNamedCtor value)? named,
  }) {
    return named?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WhateverSingleNamedCtor value)? named,
    required TResult orElse(),
  }) {
    if (named != null) {
      return named(this);
    }
    return orElse();
  }
}

abstract class WhateverSingleNamedCtor implements SingleNamedCtor {
  const factory WhateverSingleNamedCtor(final int a) =
      _$WhateverSingleNamedCtor;

  @override
  int get a;
  @override
  @JsonKey(ignore: true)
  _$$WhateverSingleNamedCtorCopyWith<_$WhateverSingleNamedCtor> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Generic<T> {
  T get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GenericCopyWith<T, Generic<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GenericCopyWith<T, $Res> {
  factory $GenericCopyWith(Generic<T> value, $Res Function(Generic<T>) then) =
      _$GenericCopyWithImpl<T, $Res, Generic<T>>;
  @useResult
  $Res call({T value});
}

/// @nodoc
class _$GenericCopyWithImpl<T, $Res, $Val extends Generic<T>>
    implements $GenericCopyWith<T, $Res> {
  _$GenericCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as T,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ACopyWith<T, $Res> implements $GenericCopyWith<T, $Res> {
  factory _$$ACopyWith(_$A<T> value, $Res Function(_$A<T>) then) =
      __$$ACopyWithImpl<T, $Res>;
  @override
  @useResult
  $Res call({T value});
}

/// @nodoc
class __$$ACopyWithImpl<T, $Res> extends _$GenericCopyWithImpl<T, $Res, _$A<T>>
    implements _$$ACopyWith<T, $Res> {
  __$$ACopyWithImpl(_$A<T> _value, $Res Function(_$A<T>) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$A<T>(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as T,
    ));
  }
}

/// @nodoc

class _$A<T> implements A<T> {
  const _$A(this.value);

  @override
  final T value;

  @override
  String toString() {
    return 'Generic<$T>(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$A<T> &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ACopyWith<T, _$A<T>> get copyWith =>
      __$$ACopyWithImpl<T, _$A<T>>(this, _$identity);
}

abstract class A<T> implements Generic<T> {
  const factory A(final T value) = _$A<T>;

  @override
  T get value;
  @override
  @JsonKey(ignore: true)
  _$$ACopyWith<T, _$A<T>> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Example {
  String get a => throw _privateConstructorUsedError;
  int? get b => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExampleCopyWith<Example> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExampleCopyWith<$Res> {
  factory $ExampleCopyWith(Example value, $Res Function(Example) then) =
      _$ExampleCopyWithImpl<$Res, Example>;
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class _$ExampleCopyWithImpl<$Res, $Val extends Example>
    implements $ExampleCopyWith<$Res> {
  _$ExampleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_value.copyWith(
      a: null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$Example0CopyWith<$Res> implements $ExampleCopyWith<$Res> {
  factory _$$Example0CopyWith(
          _$Example0 value, $Res Function(_$Example0) then) =
      __$$Example0CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String a, int? b});
}

/// @nodoc
class __$$Example0CopyWithImpl<$Res>
    extends _$ExampleCopyWithImpl<$Res, _$Example0>
    implements _$$Example0CopyWith<$Res> {
  __$$Example0CopyWithImpl(_$Example0 _value, $Res Function(_$Example0) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? a = null,
    Object? b = freezed,
  }) {
    return _then(_$Example0(
      null == a
          ? _value.a
          : a // ignore: cast_nullable_to_non_nullable
              as String,
      b: freezed == b
          ? _value.b
          : b // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$Example0 implements Example0 {
  const _$Example0(this.a, {this.b});

  @override
  final String a;
  @override
  final int? b;

  @override
  String toString() {
    return 'Example(a: $a, b: $b)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Example0 &&
            (identical(other.a, a) || other.a == a) &&
            (identical(other.b, b) || other.b == b));
  }

  @override
  int get hashCode => Object.hash(runtimeType, a, b);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Example0CopyWith<_$Example0> get copyWith =>
      __$$Example0CopyWithImpl<_$Example0>(this, _$identity);
}

abstract class Example0 implements Example {
  const factory Example0(final String a, {final int? b}) = _$Example0;

  @override
  String get a;
  @override
  int? get b;
  @override
  @JsonKey(ignore: true)
  _$$Example0CopyWith<_$Example0> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NoConst {}

/// @nodoc
abstract class $NoConstCopyWith<$Res> {
  factory $NoConstCopyWith(NoConst value, $Res Function(NoConst) then) =
      _$NoConstCopyWithImpl<$Res, NoConst>;
}

/// @nodoc
class _$NoConstCopyWithImpl<$Res, $Val extends NoConst>
    implements $NoConstCopyWith<$Res> {
  _$NoConstCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$NoConstImplCopyWith<$Res> {
  factory _$$NoConstImplCopyWith(
          _$NoConstImpl value, $Res Function(_$NoConstImpl) then) =
      __$$NoConstImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NoConstImplCopyWithImpl<$Res>
    extends _$NoConstCopyWithImpl<$Res, _$NoConstImpl>
    implements _$$NoConstImplCopyWith<$Res> {
  __$$NoConstImplCopyWithImpl(
      _$NoConstImpl _value, $Res Function(_$NoConstImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$NoConstImpl implements NoConstImpl {
  _$NoConstImpl();

  @override
  String toString() {
    return 'NoConst()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NoConstImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class NoConstImpl implements NoConst {
  factory NoConstImpl() = _$NoConstImpl;
}

/// @nodoc
mixin _$SecondState {
  String? get dateTime => throw _privateConstructorUsedError;
  String? get uuid => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SecondStateCopyWith<SecondState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SecondStateCopyWith<$Res> {
  factory $SecondStateCopyWith(
          SecondState value, $Res Function(SecondState) then) =
      _$SecondStateCopyWithImpl<$Res, SecondState>;
  @useResult
  $Res call({String? dateTime, String? uuid});
}

/// @nodoc
class _$SecondStateCopyWithImpl<$Res, $Val extends SecondState>
    implements $SecondStateCopyWith<$Res> {
  _$SecondStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTime = freezed,
    Object? uuid = freezed,
  }) {
    return _then(_value.copyWith(
      dateTime: freezed == dateTime
          ? _value.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      uuid: freezed == uuid
          ? _value.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SecondStateCopyWith<$Res>
    implements $SecondStateCopyWith<$Res> {
  factory _$$_SecondStateCopyWith(
          _$_SecondState value, $Res Function(_$_SecondState) then) =
      __$$_SecondStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String? dateTime, String? uuid});
}

/// @nodoc
class __$$_SecondStateCopyWithImpl<$Res>
    extends _$SecondStateCopyWithImpl<$Res, _$_SecondState>
    implements _$$_SecondStateCopyWith<$Res> {
  __$$_SecondStateCopyWithImpl(
      _$_SecondState _value, $Res Function(_$_SecondState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateTime = freezed,
    Object? uuid = freezed,
  }) {
    return _then(_$_SecondState(
      dateTime: freezed == dateTime
          ? _value.dateTime
          : dateTime // ignore: cast_nullable_to_non_nullable
              as String?,
      uuid: freezed == uuid
          ? _value.uuid
          : uuid // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_SecondState implements _SecondState {
  const _$_SecondState({this.dateTime, this.uuid});

  @override
  final String? dateTime;
  @override
  final String? uuid;

  @override
  String toString() {
    return 'SecondState(dateTime: $dateTime, uuid: $uuid)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SecondState &&
            (identical(other.dateTime, dateTime) ||
                other.dateTime == dateTime) &&
            (identical(other.uuid, uuid) || other.uuid == uuid));
  }

  @override
  int get hashCode => Object.hash(runtimeType, dateTime, uuid);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SecondStateCopyWith<_$_SecondState> get copyWith =>
      __$$_SecondStateCopyWithImpl<_$_SecondState>(this, _$identity);
}

abstract class _SecondState implements SecondState {
  const factory _SecondState({final String? dateTime, final String? uuid}) =
      _$_SecondState;

  @override
  String? get dateTime;
  @override
  String? get uuid;
  @override
  @JsonKey(ignore: true)
  _$$_SecondStateCopyWith<_$_SecondState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Static {}

/// @nodoc
abstract class $StaticCopyWith<$Res> {
  factory $StaticCopyWith(Static value, $Res Function(Static) then) =
      _$StaticCopyWithImpl<$Res, Static>;
}

/// @nodoc
class _$StaticCopyWithImpl<$Res, $Val extends Static>
    implements $StaticCopyWith<$Res> {
  _$StaticCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_StaticCopyWith<$Res> {
  factory _$$_StaticCopyWith(_$_Static value, $Res Function(_$_Static) then) =
      __$$_StaticCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_StaticCopyWithImpl<$Res>
    extends _$StaticCopyWithImpl<$Res, _$_Static>
    implements _$$_StaticCopyWith<$Res> {
  __$$_StaticCopyWithImpl(_$_Static _value, $Res Function(_$_Static) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Static implements _Static {
  const _$_Static();

  @override
  String toString() {
    return 'Static()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Static);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _Static implements Static {
  const factory _Static() = _$_Static;
}

/// @nodoc
mixin _$Late {
  int get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LateCopyWith<Late> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LateCopyWith<$Res> {
  factory $LateCopyWith(Late value, $Res Function(Late) then) =
      _$LateCopyWithImpl<$Res, Late>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class _$LateCopyWithImpl<$Res, $Val extends Late>
    implements $LateCopyWith<$Res> {
  _$LateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_LateCopyWith<$Res> implements $LateCopyWith<$Res> {
  factory _$$_LateCopyWith(_$_Late value, $Res Function(_$_Late) then) =
      __$$_LateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$_LateCopyWithImpl<$Res> extends _$LateCopyWithImpl<$Res, _$_Late>
    implements _$$_LateCopyWith<$Res> {
  __$$_LateCopyWithImpl(_$_Late _value, $Res Function(_$_Late) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_Late(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Late extends _Late {
  _$_Late(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Late(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Late &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_LateCopyWith<_$_Late> get copyWith =>
      __$$_LateCopyWithImpl<_$_Late>(this, _$identity);
}

abstract class _Late extends Late {
  factory _Late(final int value) = _$_Late;
  _Late._() : super._();

  @override
  int get value;
  @override
  @JsonKey(ignore: true)
  _$$_LateCopyWith<_$_Late> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AllProperties {
  int get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AllPropertiesCopyWith<AllProperties> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AllPropertiesCopyWith<$Res> {
  factory $AllPropertiesCopyWith(
          AllProperties value, $Res Function(AllProperties) then) =
      _$AllPropertiesCopyWithImpl<$Res, AllProperties>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class _$AllPropertiesCopyWithImpl<$Res, $Val extends AllProperties>
    implements $AllPropertiesCopyWith<$Res> {
  _$AllPropertiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_AllPropertiesCopyWith<$Res>
    implements $AllPropertiesCopyWith<$Res> {
  factory _$$_AllPropertiesCopyWith(
          _$_AllProperties value, $Res Function(_$_AllProperties) then) =
      __$$_AllPropertiesCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$_AllPropertiesCopyWithImpl<$Res>
    extends _$AllPropertiesCopyWithImpl<$Res, _$_AllProperties>
    implements _$$_AllPropertiesCopyWith<$Res> {
  __$$_AllPropertiesCopyWithImpl(
      _$_AllProperties _value, $Res Function(_$_AllProperties) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_AllProperties(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_AllProperties extends _AllProperties {
  _$_AllProperties(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'AllProperties(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_AllProperties &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_AllPropertiesCopyWith<_$_AllProperties> get copyWith =>
      __$$_AllPropertiesCopyWithImpl<_$_AllProperties>(this, _$identity);
}

abstract class _AllProperties extends AllProperties {
  factory _AllProperties(final int value) = _$_AllProperties;
  _AllProperties._() : super._();

  @override
  int get value;
  @override
  @JsonKey(ignore: true)
  _$$_AllPropertiesCopyWith<_$_AllProperties> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Late2 {
  int? Function() get cb => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Late2CopyWith<Late2> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Late2CopyWith<$Res> {
  factory $Late2CopyWith(Late2 value, $Res Function(Late2) then) =
      _$Late2CopyWithImpl<$Res, Late2>;
  @useResult
  $Res call({int? Function() cb});
}

/// @nodoc
class _$Late2CopyWithImpl<$Res, $Val extends Late2>
    implements $Late2CopyWith<$Res> {
  _$Late2CopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cb = null,
  }) {
    return _then(_value.copyWith(
      cb: null == cb
          ? _value.cb
          : cb // ignore: cast_nullable_to_non_nullable
              as int? Function(),
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_Late2CopyWith<$Res> implements $Late2CopyWith<$Res> {
  factory _$$_Late2CopyWith(_$_Late2 value, $Res Function(_$_Late2) then) =
      __$$_Late2CopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int? Function() cb});
}

/// @nodoc
class __$$_Late2CopyWithImpl<$Res> extends _$Late2CopyWithImpl<$Res, _$_Late2>
    implements _$$_Late2CopyWith<$Res> {
  __$$_Late2CopyWithImpl(_$_Late2 _value, $Res Function(_$_Late2) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cb = null,
  }) {
    return _then(_$_Late2(
      null == cb
          ? _value.cb
          : cb // ignore: cast_nullable_to_non_nullable
              as int? Function(),
    ));
  }
}

/// @nodoc

class _$_Late2 extends _Late2 {
  _$_Late2(this.cb) : super._();

  @override
  final int? Function() cb;

  @override
  String toString() {
    return 'Late2(cb: $cb)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Late2 &&
            (identical(other.cb, cb) || other.cb == cb));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cb);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_Late2CopyWith<_$_Late2> get copyWith =>
      __$$_Late2CopyWithImpl<_$_Late2>(this, _$identity);
}

abstract class _Late2 extends Late2 {
  factory _Late2(final int? Function() cb) = _$_Late2;
  _Late2._() : super._();

  @override
  int? Function() get cb;
  @override
  @JsonKey(ignore: true)
  _$$_Late2CopyWith<_$_Late2> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ComplexLate {
  List<int> get values => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ComplexLateCopyWith<ComplexLate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ComplexLateCopyWith<$Res> {
  factory $ComplexLateCopyWith(
          ComplexLate value, $Res Function(ComplexLate) then) =
      _$ComplexLateCopyWithImpl<$Res, ComplexLate>;
  @useResult
  $Res call({List<int> values});
}

/// @nodoc
class _$ComplexLateCopyWithImpl<$Res, $Val extends ComplexLate>
    implements $ComplexLateCopyWith<$Res> {
  _$ComplexLateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? values = null,
  }) {
    return _then(_value.copyWith(
      values: null == values
          ? _value.values
          : values // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ComplexLateCopyWith<$Res>
    implements $ComplexLateCopyWith<$Res> {
  factory _$$_ComplexLateCopyWith(
          _$_ComplexLate value, $Res Function(_$_ComplexLate) then) =
      __$$_ComplexLateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<int> values});
}

/// @nodoc
class __$$_ComplexLateCopyWithImpl<$Res>
    extends _$ComplexLateCopyWithImpl<$Res, _$_ComplexLate>
    implements _$$_ComplexLateCopyWith<$Res> {
  __$$_ComplexLateCopyWithImpl(
      _$_ComplexLate _value, $Res Function(_$_ComplexLate) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? values = null,
  }) {
    return _then(_$_ComplexLate(
      null == values
          ? _value._values
          : values // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$_ComplexLate extends _ComplexLate {
  _$_ComplexLate(final List<int> values)
      : _values = values,
        super._();

  final List<int> _values;
  @override
  List<int> get values {
    if (_values is EqualUnmodifiableListView) return _values;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_values);
  }

  @override
  String toString() {
    return 'ComplexLate(values: $values)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ComplexLate &&
            const DeepCollectionEquality().equals(other._values, _values));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_values));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ComplexLateCopyWith<_$_ComplexLate> get copyWith =>
      __$$_ComplexLateCopyWithImpl<_$_ComplexLate>(this, _$identity);
}

abstract class _ComplexLate extends ComplexLate {
  factory _ComplexLate(final List<int> values) = _$_ComplexLate;
  _ComplexLate._() : super._();

  @override
  List<int> get values;
  @override
  @JsonKey(ignore: true)
  _$$_ComplexLateCopyWith<_$_ComplexLate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$IntDefault {
  int get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $IntDefaultCopyWith<IntDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $IntDefaultCopyWith<$Res> {
  factory $IntDefaultCopyWith(
          IntDefault value, $Res Function(IntDefault) then) =
      _$IntDefaultCopyWithImpl<$Res, IntDefault>;
  @useResult
  $Res call({int value});
}

/// @nodoc
class _$IntDefaultCopyWithImpl<$Res, $Val extends IntDefault>
    implements $IntDefaultCopyWith<$Res> {
  _$IntDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_IntDefaultCopyWith<$Res>
    implements $IntDefaultCopyWith<$Res> {
  factory _$$_IntDefaultCopyWith(
          _$_IntDefault value, $Res Function(_$_IntDefault) then) =
      __$$_IntDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int value});
}

/// @nodoc
class __$$_IntDefaultCopyWithImpl<$Res>
    extends _$IntDefaultCopyWithImpl<$Res, _$_IntDefault>
    implements _$$_IntDefaultCopyWith<$Res> {
  __$$_IntDefaultCopyWithImpl(
      _$_IntDefault _value, $Res Function(_$_IntDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_IntDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_IntDefault implements _IntDefault {
  _$_IntDefault([this.value = 42]);

  @override
  @JsonKey()
  final int value;

  @override
  String toString() {
    return 'IntDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_IntDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_IntDefaultCopyWith<_$_IntDefault> get copyWith =>
      __$$_IntDefaultCopyWithImpl<_$_IntDefault>(this, _$identity);
}

abstract class _IntDefault implements IntDefault {
  factory _IntDefault([final int value]) = _$_IntDefault;

  @override
  int get value;
  @override
  @JsonKey(ignore: true)
  _$$_IntDefaultCopyWith<_$_IntDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StringDefault {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StringDefaultCopyWith<StringDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StringDefaultCopyWith<$Res> {
  factory $StringDefaultCopyWith(
          StringDefault value, $Res Function(StringDefault) then) =
      _$StringDefaultCopyWithImpl<$Res, StringDefault>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$StringDefaultCopyWithImpl<$Res, $Val extends StringDefault>
    implements $StringDefaultCopyWith<$Res> {
  _$StringDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StringDefaultCopyWith<$Res>
    implements $StringDefaultCopyWith<$Res> {
  factory _$$_StringDefaultCopyWith(
          _$_StringDefault value, $Res Function(_$_StringDefault) then) =
      __$$_StringDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$_StringDefaultCopyWithImpl<$Res>
    extends _$StringDefaultCopyWithImpl<$Res, _$_StringDefault>
    implements _$$_StringDefaultCopyWith<$Res> {
  __$$_StringDefaultCopyWithImpl(
      _$_StringDefault _value, $Res Function(_$_StringDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_StringDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_StringDefault implements _StringDefault {
  _$_StringDefault([this.value = '42']);

  @override
  @JsonKey()
  final String value;

  @override
  String toString() {
    return 'StringDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StringDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StringDefaultCopyWith<_$_StringDefault> get copyWith =>
      __$$_StringDefaultCopyWithImpl<_$_StringDefault>(this, _$identity);
}

abstract class _StringDefault implements StringDefault {
  factory _StringDefault([final String value]) = _$_StringDefault;

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_StringDefaultCopyWith<_$_StringDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SpecialStringDefault {
  String get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SpecialStringDefaultCopyWith<SpecialStringDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SpecialStringDefaultCopyWith<$Res> {
  factory $SpecialStringDefaultCopyWith(SpecialStringDefault value,
          $Res Function(SpecialStringDefault) then) =
      _$SpecialStringDefaultCopyWithImpl<$Res, SpecialStringDefault>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$SpecialStringDefaultCopyWithImpl<$Res,
        $Val extends SpecialStringDefault>
    implements $SpecialStringDefaultCopyWith<$Res> {
  _$SpecialStringDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SpecialStringDefaultCopyWith<$Res>
    implements $SpecialStringDefaultCopyWith<$Res> {
  factory _$$_SpecialStringDefaultCopyWith(_$_SpecialStringDefault value,
          $Res Function(_$_SpecialStringDefault) then) =
      __$$_SpecialStringDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$_SpecialStringDefaultCopyWithImpl<$Res>
    extends _$SpecialStringDefaultCopyWithImpl<$Res, _$_SpecialStringDefault>
    implements _$$_SpecialStringDefaultCopyWith<$Res> {
  __$$_SpecialStringDefaultCopyWithImpl(_$_SpecialStringDefault _value,
      $Res Function(_$_SpecialStringDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_SpecialStringDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_SpecialStringDefault implements _SpecialStringDefault {
  _$_SpecialStringDefault([this.value = '(1)[2]{3}']);

  @override
  @JsonKey()
  final String value;

  @override
  String toString() {
    return 'SpecialStringDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SpecialStringDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SpecialStringDefaultCopyWith<_$_SpecialStringDefault> get copyWith =>
      __$$_SpecialStringDefaultCopyWithImpl<_$_SpecialStringDefault>(
          this, _$identity);
}

abstract class _SpecialStringDefault implements SpecialStringDefault {
  factory _SpecialStringDefault([final String value]) = _$_SpecialStringDefault;

  @override
  String get value;
  @override
  @JsonKey(ignore: true)
  _$$_SpecialStringDefaultCopyWith<_$_SpecialStringDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DefaultNonLitteralConst {
  Object get listObject => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DefaultNonLitteralConstCopyWith<DefaultNonLitteralConst> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DefaultNonLitteralConstCopyWith<$Res> {
  factory $DefaultNonLitteralConstCopyWith(DefaultNonLitteralConst value,
          $Res Function(DefaultNonLitteralConst) then) =
      _$DefaultNonLitteralConstCopyWithImpl<$Res, DefaultNonLitteralConst>;
  @useResult
  $Res call({Object listObject});
}

/// @nodoc
class _$DefaultNonLitteralConstCopyWithImpl<$Res,
        $Val extends DefaultNonLitteralConst>
    implements $DefaultNonLitteralConstCopyWith<$Res> {
  _$DefaultNonLitteralConstCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listObject = null,
  }) {
    return _then(_value.copyWith(
      listObject: null == listObject ? _value.listObject : listObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DefaultNonLitteralConstCopyWith<$Res>
    implements $DefaultNonLitteralConstCopyWith<$Res> {
  factory _$$_DefaultNonLitteralConstCopyWith(_$_DefaultNonLitteralConst value,
          $Res Function(_$_DefaultNonLitteralConst) then) =
      __$$_DefaultNonLitteralConstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object listObject});
}

/// @nodoc
class __$$_DefaultNonLitteralConstCopyWithImpl<$Res>
    extends _$DefaultNonLitteralConstCopyWithImpl<$Res,
        _$_DefaultNonLitteralConst>
    implements _$$_DefaultNonLitteralConstCopyWith<$Res> {
  __$$_DefaultNonLitteralConstCopyWithImpl(_$_DefaultNonLitteralConst _value,
      $Res Function(_$_DefaultNonLitteralConst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listObject = null,
  }) {
    return _then(_$_DefaultNonLitteralConst(
      listObject: null == listObject ? _value.listObject : listObject,
    ));
  }
}

/// @nodoc

class _$_DefaultNonLitteralConst implements _DefaultNonLitteralConst {
  _$_DefaultNonLitteralConst({this.listObject = const Object()});

  @override
  @JsonKey()
  final Object listObject;

  @override
  String toString() {
    return 'DefaultNonLitteralConst(listObject: $listObject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DefaultNonLitteralConst &&
            const DeepCollectionEquality()
                .equals(other.listObject, listObject));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(listObject));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DefaultNonLitteralConstCopyWith<_$_DefaultNonLitteralConst>
      get copyWith =>
          __$$_DefaultNonLitteralConstCopyWithImpl<_$_DefaultNonLitteralConst>(
              this, _$identity);
}

abstract class _DefaultNonLitteralConst implements DefaultNonLitteralConst {
  factory _DefaultNonLitteralConst({final Object listObject}) =
      _$_DefaultNonLitteralConst;

  @override
  Object get listObject;
  @override
  @JsonKey(ignore: true)
  _$$_DefaultNonLitteralConstCopyWith<_$_DefaultNonLitteralConst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DefaultNonLitteralAlreadyConst {
  Object get listObject => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DefaultNonLitteralAlreadyConstCopyWith<DefaultNonLitteralAlreadyConst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DefaultNonLitteralAlreadyConstCopyWith<$Res> {
  factory $DefaultNonLitteralAlreadyConstCopyWith(
          DefaultNonLitteralAlreadyConst value,
          $Res Function(DefaultNonLitteralAlreadyConst) then) =
      _$DefaultNonLitteralAlreadyConstCopyWithImpl<$Res,
          DefaultNonLitteralAlreadyConst>;
  @useResult
  $Res call({Object listObject});
}

/// @nodoc
class _$DefaultNonLitteralAlreadyConstCopyWithImpl<$Res,
        $Val extends DefaultNonLitteralAlreadyConst>
    implements $DefaultNonLitteralAlreadyConstCopyWith<$Res> {
  _$DefaultNonLitteralAlreadyConstCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listObject = null,
  }) {
    return _then(_value.copyWith(
      listObject: null == listObject ? _value.listObject : listObject,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DefaultNonLitteralAlreadyConstCopyWith<$Res>
    implements $DefaultNonLitteralAlreadyConstCopyWith<$Res> {
  factory _$$_DefaultNonLitteralAlreadyConstCopyWith(
          _$_DefaultNonLitteralAlreadyConst value,
          $Res Function(_$_DefaultNonLitteralAlreadyConst) then) =
      __$$_DefaultNonLitteralAlreadyConstCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Object listObject});
}

/// @nodoc
class __$$_DefaultNonLitteralAlreadyConstCopyWithImpl<$Res>
    extends _$DefaultNonLitteralAlreadyConstCopyWithImpl<$Res,
        _$_DefaultNonLitteralAlreadyConst>
    implements _$$_DefaultNonLitteralAlreadyConstCopyWith<$Res> {
  __$$_DefaultNonLitteralAlreadyConstCopyWithImpl(
      _$_DefaultNonLitteralAlreadyConst _value,
      $Res Function(_$_DefaultNonLitteralAlreadyConst) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? listObject = null,
  }) {
    return _then(_$_DefaultNonLitteralAlreadyConst(
      listObject: null == listObject ? _value.listObject : listObject,
    ));
  }
}

/// @nodoc

class _$_DefaultNonLitteralAlreadyConst
    implements _DefaultNonLitteralAlreadyConst {
  _$_DefaultNonLitteralAlreadyConst({this.listObject = const Object()});

  @override
  @JsonKey()
  final Object listObject;

  @override
  String toString() {
    return 'DefaultNonLitteralAlreadyConst(listObject: $listObject)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DefaultNonLitteralAlreadyConst &&
            const DeepCollectionEquality()
                .equals(other.listObject, listObject));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(listObject));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DefaultNonLitteralAlreadyConstCopyWith<_$_DefaultNonLitteralAlreadyConst>
      get copyWith => __$$_DefaultNonLitteralAlreadyConstCopyWithImpl<
          _$_DefaultNonLitteralAlreadyConst>(this, _$identity);
}

abstract class _DefaultNonLitteralAlreadyConst
    implements DefaultNonLitteralAlreadyConst {
  factory _DefaultNonLitteralAlreadyConst({final Object listObject}) =
      _$_DefaultNonLitteralAlreadyConst;

  @override
  Object get listObject;
  @override
  @JsonKey(ignore: true)
  _$$_DefaultNonLitteralAlreadyConstCopyWith<_$_DefaultNonLitteralAlreadyConst>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DoubleDefault {
  double get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $DoubleDefaultCopyWith<DoubleDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DoubleDefaultCopyWith<$Res> {
  factory $DoubleDefaultCopyWith(
          DoubleDefault value, $Res Function(DoubleDefault) then) =
      _$DoubleDefaultCopyWithImpl<$Res, DoubleDefault>;
  @useResult
  $Res call({double value});
}

/// @nodoc
class _$DoubleDefaultCopyWithImpl<$Res, $Val extends DoubleDefault>
    implements $DoubleDefaultCopyWith<$Res> {
  _$DoubleDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_DoubleDefaultCopyWith<$Res>
    implements $DoubleDefaultCopyWith<$Res> {
  factory _$$_DoubleDefaultCopyWith(
          _$_DoubleDefault value, $Res Function(_$_DoubleDefault) then) =
      __$$_DoubleDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double value});
}

/// @nodoc
class __$$_DoubleDefaultCopyWithImpl<$Res>
    extends _$DoubleDefaultCopyWithImpl<$Res, _$_DoubleDefault>
    implements _$$_DoubleDefaultCopyWith<$Res> {
  __$$_DoubleDefaultCopyWithImpl(
      _$_DoubleDefault _value, $Res Function(_$_DoubleDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_DoubleDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_DoubleDefault implements _DoubleDefault {
  _$_DoubleDefault([this.value = 42.0]);

  @override
  @JsonKey()
  final double value;

  @override
  String toString() {
    return 'DoubleDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_DoubleDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_DoubleDefaultCopyWith<_$_DoubleDefault> get copyWith =>
      __$$_DoubleDefaultCopyWithImpl<_$_DoubleDefault>(this, _$identity);
}

abstract class _DoubleDefault implements DoubleDefault {
  factory _DoubleDefault([final double value]) = _$_DoubleDefault;

  @override
  double get value;
  @override
  @JsonKey(ignore: true)
  _$$_DoubleDefaultCopyWith<_$_DoubleDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$TypeDefault {
  Type get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $TypeDefaultCopyWith<TypeDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TypeDefaultCopyWith<$Res> {
  factory $TypeDefaultCopyWith(
          TypeDefault value, $Res Function(TypeDefault) then) =
      _$TypeDefaultCopyWithImpl<$Res, TypeDefault>;
  @useResult
  $Res call({Type value});
}

/// @nodoc
class _$TypeDefaultCopyWithImpl<$Res, $Val extends TypeDefault>
    implements $TypeDefaultCopyWith<$Res> {
  _$TypeDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Type,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_TypeDefaultCopyWith<$Res>
    implements $TypeDefaultCopyWith<$Res> {
  factory _$$_TypeDefaultCopyWith(
          _$_TypeDefault value, $Res Function(_$_TypeDefault) then) =
      __$$_TypeDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Type value});
}

/// @nodoc
class __$$_TypeDefaultCopyWithImpl<$Res>
    extends _$TypeDefaultCopyWithImpl<$Res, _$_TypeDefault>
    implements _$$_TypeDefaultCopyWith<$Res> {
  __$$_TypeDefaultCopyWithImpl(
      _$_TypeDefault _value, $Res Function(_$_TypeDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_TypeDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Type,
    ));
  }
}

/// @nodoc

class _$_TypeDefault implements _TypeDefault {
  _$_TypeDefault([this.value = TypeDefault]);

  @override
  @JsonKey()
  final Type value;

  @override
  String toString() {
    return 'TypeDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_TypeDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_TypeDefaultCopyWith<_$_TypeDefault> get copyWith =>
      __$$_TypeDefaultCopyWithImpl<_$_TypeDefault>(this, _$identity);
}

abstract class _TypeDefault implements TypeDefault {
  factory _TypeDefault([final Type value]) = _$_TypeDefault;

  @override
  Type get value;
  @override
  @JsonKey(ignore: true)
  _$$_TypeDefaultCopyWith<_$_TypeDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ListDefault {
  List<int> get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ListDefaultCopyWith<ListDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListDefaultCopyWith<$Res> {
  factory $ListDefaultCopyWith(
          ListDefault value, $Res Function(ListDefault) then) =
      _$ListDefaultCopyWithImpl<$Res, ListDefault>;
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class _$ListDefaultCopyWithImpl<$Res, $Val extends ListDefault>
    implements $ListDefaultCopyWith<$Res> {
  _$ListDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ListDefaultCopyWith<$Res>
    implements $ListDefaultCopyWith<$Res> {
  factory _$$_ListDefaultCopyWith(
          _$_ListDefault value, $Res Function(_$_ListDefault) then) =
      __$$_ListDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<int> value});
}

/// @nodoc
class __$$_ListDefaultCopyWithImpl<$Res>
    extends _$ListDefaultCopyWithImpl<$Res, _$_ListDefault>
    implements _$$_ListDefaultCopyWith<$Res> {
  __$$_ListDefaultCopyWithImpl(
      _$_ListDefault _value, $Res Function(_$_ListDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_ListDefault(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<int>,
    ));
  }
}

/// @nodoc

class _$_ListDefault implements _ListDefault {
  _$_ListDefault([final List<int> value = const <int>[42]]) : _value = value;

  final List<int> _value;
  @override
  @JsonKey()
  List<int> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @override
  String toString() {
    return 'ListDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ListDefault &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ListDefaultCopyWith<_$_ListDefault> get copyWith =>
      __$$_ListDefaultCopyWithImpl<_$_ListDefault>(this, _$identity);
}

abstract class _ListDefault implements ListDefault {
  factory _ListDefault([final List<int> value]) = _$_ListDefault;

  @override
  List<int> get value;
  @override
  @JsonKey(ignore: true)
  _$$_ListDefaultCopyWith<_$_ListDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SetDefault {
  Set<int> get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SetDefaultCopyWith<SetDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetDefaultCopyWith<$Res> {
  factory $SetDefaultCopyWith(
          SetDefault value, $Res Function(SetDefault) then) =
      _$SetDefaultCopyWithImpl<$Res, SetDefault>;
  @useResult
  $Res call({Set<int> value});
}

/// @nodoc
class _$SetDefaultCopyWithImpl<$Res, $Val extends SetDefault>
    implements $SetDefaultCopyWith<$Res> {
  _$SetDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_SetDefaultCopyWith<$Res>
    implements $SetDefaultCopyWith<$Res> {
  factory _$$_SetDefaultCopyWith(
          _$_SetDefault value, $Res Function(_$_SetDefault) then) =
      __$$_SetDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Set<int> value});
}

/// @nodoc
class __$$_SetDefaultCopyWithImpl<$Res>
    extends _$SetDefaultCopyWithImpl<$Res, _$_SetDefault>
    implements _$$_SetDefaultCopyWith<$Res> {
  __$$_SetDefaultCopyWithImpl(
      _$_SetDefault _value, $Res Function(_$_SetDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_SetDefault(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as Set<int>,
    ));
  }
}

/// @nodoc

class _$_SetDefault implements _SetDefault {
  _$_SetDefault([final Set<int> value = const <int>{42}]) : _value = value;

  final Set<int> _value;
  @override
  @JsonKey()
  Set<int> get value {
    if (_value is EqualUnmodifiableSetView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_value);
  }

  @override
  String toString() {
    return 'SetDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SetDefault &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SetDefaultCopyWith<_$_SetDefault> get copyWith =>
      __$$_SetDefaultCopyWithImpl<_$_SetDefault>(this, _$identity);
}

abstract class _SetDefault implements SetDefault {
  factory _SetDefault([final Set<int> value]) = _$_SetDefault;

  @override
  Set<int> get value;
  @override
  @JsonKey(ignore: true)
  _$$_SetDefaultCopyWith<_$_SetDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$MapDefault {
  Map<int, int> get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MapDefaultCopyWith<MapDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MapDefaultCopyWith<$Res> {
  factory $MapDefaultCopyWith(
          MapDefault value, $Res Function(MapDefault) then) =
      _$MapDefaultCopyWithImpl<$Res, MapDefault>;
  @useResult
  $Res call({Map<int, int> value});
}

/// @nodoc
class _$MapDefaultCopyWithImpl<$Res, $Val extends MapDefault>
    implements $MapDefaultCopyWith<$Res> {
  _$MapDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Map<int, int>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_MapDefaultCopyWith<$Res>
    implements $MapDefaultCopyWith<$Res> {
  factory _$$_MapDefaultCopyWith(
          _$_MapDefault value, $Res Function(_$_MapDefault) then) =
      __$$_MapDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Map<int, int> value});
}

/// @nodoc
class __$$_MapDefaultCopyWithImpl<$Res>
    extends _$MapDefaultCopyWithImpl<$Res, _$_MapDefault>
    implements _$$_MapDefaultCopyWith<$Res> {
  __$$_MapDefaultCopyWithImpl(
      _$_MapDefault _value, $Res Function(_$_MapDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_MapDefault(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as Map<int, int>,
    ));
  }
}

/// @nodoc

class _$_MapDefault implements _MapDefault {
  _$_MapDefault([final Map<int, int> value = const <int, int>{42: 42}])
      : _value = value;

  final Map<int, int> _value;
  @override
  @JsonKey()
  Map<int, int> get value {
    if (_value is EqualUnmodifiableMapView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_value);
  }

  @override
  String toString() {
    return 'MapDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_MapDefault &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_MapDefaultCopyWith<_$_MapDefault> get copyWith =>
      __$$_MapDefaultCopyWithImpl<_$_MapDefault>(this, _$identity);
}

abstract class _MapDefault implements MapDefault {
  factory _MapDefault([final Map<int, int> value]) = _$_MapDefault;

  @override
  Map<int, int> get value;
  @override
  @JsonKey(ignore: true)
  _$$_MapDefaultCopyWith<_$_MapDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BoolDefault {
  bool get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BoolDefaultCopyWith<BoolDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoolDefaultCopyWith<$Res> {
  factory $BoolDefaultCopyWith(
          BoolDefault value, $Res Function(BoolDefault) then) =
      _$BoolDefaultCopyWithImpl<$Res, BoolDefault>;
  @useResult
  $Res call({bool value});
}

/// @nodoc
class _$BoolDefaultCopyWithImpl<$Res, $Val extends BoolDefault>
    implements $BoolDefaultCopyWith<$Res> {
  _$BoolDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_BoolDefaultCopyWith<$Res>
    implements $BoolDefaultCopyWith<$Res> {
  factory _$$_BoolDefaultCopyWith(
          _$_BoolDefault value, $Res Function(_$_BoolDefault) then) =
      __$$_BoolDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool value});
}

/// @nodoc
class __$$_BoolDefaultCopyWithImpl<$Res>
    extends _$BoolDefaultCopyWithImpl<$Res, _$_BoolDefault>
    implements _$$_BoolDefaultCopyWith<$Res> {
  __$$_BoolDefaultCopyWithImpl(
      _$_BoolDefault _value, $Res Function(_$_BoolDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_BoolDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_BoolDefault implements _BoolDefault {
  _$_BoolDefault([this.value = false]);

  @override
  @JsonKey()
  final bool value;

  @override
  String toString() {
    return 'BoolDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_BoolDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_BoolDefaultCopyWith<_$_BoolDefault> get copyWith =>
      __$$_BoolDefaultCopyWithImpl<_$_BoolDefault>(this, _$identity);
}

abstract class _BoolDefault implements BoolDefault {
  factory _BoolDefault([final bool value]) = _$_BoolDefault;

  @override
  bool get value;
  @override
  @JsonKey(ignore: true)
  _$$_BoolDefaultCopyWith<_$_BoolDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NullDefault {
  bool? get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $NullDefaultCopyWith<NullDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NullDefaultCopyWith<$Res> {
  factory $NullDefaultCopyWith(
          NullDefault value, $Res Function(NullDefault) then) =
      _$NullDefaultCopyWithImpl<$Res, NullDefault>;
  @useResult
  $Res call({bool? value});
}

/// @nodoc
class _$NullDefaultCopyWithImpl<$Res, $Val extends NullDefault>
    implements $NullDefaultCopyWith<$Res> {
  _$NullDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      value: freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_NullDefaultCopyWith<$Res>
    implements $NullDefaultCopyWith<$Res> {
  factory _$$_NullDefaultCopyWith(
          _$_NullDefault value, $Res Function(_$_NullDefault) then) =
      __$$_NullDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool? value});
}

/// @nodoc
class __$$_NullDefaultCopyWithImpl<$Res>
    extends _$NullDefaultCopyWithImpl<$Res, _$_NullDefault>
    implements _$$_NullDefaultCopyWith<$Res> {
  __$$_NullDefaultCopyWithImpl(
      _$_NullDefault _value, $Res Function(_$_NullDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_$_NullDefault(
      freezed == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$_NullDefault implements _NullDefault {
  _$_NullDefault([this.value = null]);

  @override
  @JsonKey()
  final bool? value;

  @override
  String toString() {
    return 'NullDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_NullDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_NullDefaultCopyWith<_$_NullDefault> get copyWith =>
      __$$_NullDefaultCopyWithImpl<_$_NullDefault>(this, _$identity);
}

abstract class _NullDefault implements NullDefault {
  factory _NullDefault([final bool? value]) = _$_NullDefault;

  @override
  bool? get value;
  @override
  @JsonKey(ignore: true)
  _$$_NullDefaultCopyWith<_$_NullDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExplicitConstDefault {
  List<Object> get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ExplicitConstDefaultCopyWith<ExplicitConstDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExplicitConstDefaultCopyWith<$Res> {
  factory $ExplicitConstDefaultCopyWith(ExplicitConstDefault value,
          $Res Function(ExplicitConstDefault) then) =
      _$ExplicitConstDefaultCopyWithImpl<$Res, ExplicitConstDefault>;
  @useResult
  $Res call({List<Object> value});
}

/// @nodoc
class _$ExplicitConstDefaultCopyWithImpl<$Res,
        $Val extends ExplicitConstDefault>
    implements $ExplicitConstDefaultCopyWith<$Res> {
  _$ExplicitConstDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as List<Object>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ExplicitConstDefaultCopyWith<$Res>
    implements $ExplicitConstDefaultCopyWith<$Res> {
  factory _$$_ExplicitConstDefaultCopyWith(_$_ExplicitConstDefault value,
          $Res Function(_$_ExplicitConstDefault) then) =
      __$$_ExplicitConstDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({List<Object> value});
}

/// @nodoc
class __$$_ExplicitConstDefaultCopyWithImpl<$Res>
    extends _$ExplicitConstDefaultCopyWithImpl<$Res, _$_ExplicitConstDefault>
    implements _$$_ExplicitConstDefaultCopyWith<$Res> {
  __$$_ExplicitConstDefaultCopyWithImpl(_$_ExplicitConstDefault _value,
      $Res Function(_$_ExplicitConstDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_ExplicitConstDefault(
      null == value
          ? _value._value
          : value // ignore: cast_nullable_to_non_nullable
              as List<Object>,
    ));
  }
}

/// @nodoc

class _$_ExplicitConstDefault implements _ExplicitConstDefault {
  _$_ExplicitConstDefault([final List<Object> value = const <Object>[]])
      : _value = value;

  final List<Object> _value;
  @override
  @JsonKey()
  List<Object> get value {
    if (_value is EqualUnmodifiableListView) return _value;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_value);
  }

  @override
  String toString() {
    return 'ExplicitConstDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ExplicitConstDefault &&
            const DeepCollectionEquality().equals(other._value, _value));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_value));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ExplicitConstDefaultCopyWith<_$_ExplicitConstDefault> get copyWith =>
      __$$_ExplicitConstDefaultCopyWithImpl<_$_ExplicitConstDefault>(
          this, _$identity);
}

abstract class _ExplicitConstDefault implements ExplicitConstDefault {
  factory _ExplicitConstDefault([final List<Object> value]) =
      _$_ExplicitConstDefault;

  @override
  List<Object> get value;
  @override
  @JsonKey(ignore: true)
  _$$_ExplicitConstDefaultCopyWith<_$_ExplicitConstDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$StaticConstDefault {
  Duration get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StaticConstDefaultCopyWith<StaticConstDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StaticConstDefaultCopyWith<$Res> {
  factory $StaticConstDefaultCopyWith(
          StaticConstDefault value, $Res Function(StaticConstDefault) then) =
      _$StaticConstDefaultCopyWithImpl<$Res, StaticConstDefault>;
  @useResult
  $Res call({Duration value});
}

/// @nodoc
class _$StaticConstDefaultCopyWithImpl<$Res, $Val extends StaticConstDefault>
    implements $StaticConstDefaultCopyWith<$Res> {
  _$StaticConstDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Duration,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_StaticConstDefaultCopyWith<$Res>
    implements $StaticConstDefaultCopyWith<$Res> {
  factory _$$_StaticConstDefaultCopyWith(_$_StaticConstDefault value,
          $Res Function(_$_StaticConstDefault) then) =
      __$$_StaticConstDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Duration value});
}

/// @nodoc
class __$$_StaticConstDefaultCopyWithImpl<$Res>
    extends _$StaticConstDefaultCopyWithImpl<$Res, _$_StaticConstDefault>
    implements _$$_StaticConstDefaultCopyWith<$Res> {
  __$$_StaticConstDefaultCopyWithImpl(
      _$_StaticConstDefault _value, $Res Function(_$_StaticConstDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_StaticConstDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc

class _$_StaticConstDefault implements _StaticConstDefault {
  _$_StaticConstDefault([this.value = Duration.zero]);

  @override
  @JsonKey()
  final Duration value;

  @override
  String toString() {
    return 'StaticConstDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_StaticConstDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_StaticConstDefaultCopyWith<_$_StaticConstDefault> get copyWith =>
      __$$_StaticConstDefaultCopyWithImpl<_$_StaticConstDefault>(
          this, _$identity);
}

abstract class _StaticConstDefault implements StaticConstDefault {
  factory _StaticConstDefault([final Duration value]) = _$_StaticConstDefault;

  @override
  Duration get value;
  @override
  @JsonKey(ignore: true)
  _$$_StaticConstDefaultCopyWith<_$_StaticConstDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EnumDefault {
  _Enum get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EnumDefaultCopyWith<EnumDefault> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnumDefaultCopyWith<$Res> {
  factory $EnumDefaultCopyWith(
          EnumDefault value, $Res Function(EnumDefault) then) =
      _$EnumDefaultCopyWithImpl<$Res, EnumDefault>;
  @useResult
  $Res call({_Enum value});
}

/// @nodoc
class _$EnumDefaultCopyWithImpl<$Res, $Val extends EnumDefault>
    implements $EnumDefaultCopyWith<$Res> {
  _$EnumDefaultCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as _Enum,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_EnumDefaultCopyWith<$Res>
    implements $EnumDefaultCopyWith<$Res> {
  factory _$$_EnumDefaultCopyWith(
          _$_EnumDefault value, $Res Function(_$_EnumDefault) then) =
      __$$_EnumDefaultCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({_Enum value});
}

/// @nodoc
class __$$_EnumDefaultCopyWithImpl<$Res>
    extends _$EnumDefaultCopyWithImpl<$Res, _$_EnumDefault>
    implements _$$_EnumDefaultCopyWith<$Res> {
  __$$_EnumDefaultCopyWithImpl(
      _$_EnumDefault _value, $Res Function(_$_EnumDefault) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$_EnumDefault(
      null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as _Enum,
    ));
  }
}

/// @nodoc

class _$_EnumDefault implements _EnumDefault {
  _$_EnumDefault([this.value = _Enum.a]);

  @override
  @JsonKey()
  final _Enum value;

  @override
  String toString() {
    return 'EnumDefault(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_EnumDefault &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_EnumDefaultCopyWith<_$_EnumDefault> get copyWith =>
      __$$_EnumDefaultCopyWithImpl<_$_EnumDefault>(this, _$identity);
}

abstract class _EnumDefault implements EnumDefault {
  factory _EnumDefault([final _Enum value]) = _$_EnumDefault;

  @override
  _Enum get value;
  @override
  @JsonKey(ignore: true)
  _$$_EnumDefaultCopyWith<_$_EnumDefault> get copyWith =>
      throw _privateConstructorUsedError;
}
